{
	"arr" : [
		{

			"title":"数据结构思维导图",
			"content":"\n                    <div class=\"markdown_views\">\n                <div id=\"article_content\" class=\"article_content csdn-tracking-statistics\">\n                    <div class=\"markdown_views\">\n                <h1 id=\"数据结构宏观导图\"><a target=\"_blank\"/><font face=\"宋体\"> 数据结构宏观导图</font></h1>\n\n<p/><div align=\"cente\"> <br/>\n<img src=\"https://img-blog.csdn.net/20170812113757126\" alt=\"这里写图片描述\" title=\"\"/></div><p/>\n\n<h2 id=\"数据结构-第一章概论\"><a target=\"_blank\"/>数据结构-第一章概论</h2>\n\n<div align=\"center\"><img src=\"https://img-blog.csdn.net/20170729220314071\" width=\"1200\" height=\"700\"/>\n\n\n\n\n\n</div>\n\n<h2 id=\"数据结构第二章-线性表\"><a target=\"_blank\"/>数据结构第二章-线性表</h2>\n\n<p/><div align=\"center\"> <br/>\n<img src=\"https://img-blog.csdn.net/20170723162825807?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWVlaWkhDOTk5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\"/></div><p/>\n\n<h2 id=\"数据结构第三章-栈队列数组\"><a target=\"_blank\"/>数据结构第三章-栈、队列、数组</h2>\n\n<p/><div align=\"center\"> <br/>\n<img src=\"https://img-blog.csdn.net/20170812152520156?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWVlaWkhDOTk5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\"/></div><p/>\n\n<h2 id=\"数据结构第四章-树与二叉树\"><a target=\"_blank\"/>数据结构第四章-树与二叉树</h2>\n\n<p/><div align=\"center\"> <br/>\n<img src=\"https://img-blog.csdn.net/20170816124006462?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWVlaWkhDOTk5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\"/></div><p/>\n\n<h2 id=\"数据结构第五章图\"><a target=\"_blank\"/>数据结构第五章–图</h2>\n\n<p/><div align=\"center\"> <br/>\n<img src=\"https://img-blog.csdn.net/20171016105628951?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWVlaWkhDOTk5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\"/></div><p/>\n\n<h2 id=\"数据结构第六章查找\"><a target=\"_blank\"/>数据结构第六章–查找</h2>\n\n<p/><p/><div align=\"center\"> <br/>\n<img src=\"https://img-blog.csdn.net/20171016105747769?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvWVlaWkhDOTk5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\"/></div><p/>            </div> <br/>\n                         <br/>\n                            </div> <br/>\n原文地址：<a href=\"https://blog.csdn.net/yyzzhc999/article/details/75923540\">https://blog.csdn.net/yyzzhc999/article/details/75923540</a>            </div>\n            <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css\"/>\n                ",
			"keywords":["data_structure"]
		},
		{

			"title":"数据结构与算法（java版）",
			"content":"\n                    <div class=\"markdown_views\">\n                <p>转自：<a href=\"http://blog.csdn.net/column/details/datastructureinjava.html\">http://blog.csdn.net/column/details/datastructureinjava.html</a> <br/>\n目录 <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/42059675\">（1）数据结构与算法概念解析</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/41774325\">（2）数据结构之数组</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/41785717\">（3）数据结构之栈</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/41799569\">（4）数据结构之队列</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/41889329\">（5）数据结构之链表</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/42059325\">（6）数据结构之二叉树</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/42059461\">（7）数据结构之霍夫曼树</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/46825969\">（8）数据结构之红黑树（一）——基础分析</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/47129005\">（9）数据结构之红黑树（二）——插入操作</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/47129179\">（10）数据结构之红黑树（三）——删除操作</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/47305859\">（11）排序算法（一）——冒泡排序及改进</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/47306053\">（12）排序算法（二）——选择排序及改进</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/47306209\">（13）排序算法（三）——插入排序及改进</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/47345107\">（14）排序算法（四）——归并排序与递归</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/47379295\">（15）排序算法（五）——快速排序</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/47405799\">（16）排序算法（六）——希尔排序</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/47452813\">（17）排序算法（七）——堆排序</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/47702673\">（18）排序算法（八）——基数排序</a> <br/>\n<a href=\"http://blog.csdn.net/u012152619/article/details/47730021\">（19）排序算法（九）——八大排序算法总结</a></p>            </div>\n            <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css\"/>\n                ",
			"keywords":["data_structure"]
		},
		{

			"title":"数据结构——小白入门篇",
			"content":"\n                    <div class=\"markdown_views\">\n                <h1 id=\"数据结构小白入门篇\">数据结构——小白入门篇</h1>\n\n<h3 id=\"浅谈学习心得\">浅谈学习心得</h3>\n\n<h2 id=\"我为什么想要学数据结构\">- <strong><em>我为什么想要学数据结构？</em></strong></h2>\n\n<pre><code>****在计算机界有这样一个万能公式：数据结构 + 算法 = 程序。****\n\n在如今这计算机引领风骚的时代，不学数据结构，你凭什么想要做时代的弄潮儿；所以我毅然决然的提前自学了数据结构。\n ***\n</code></pre>\n\n<ul>\n<li><p><strong><em>学习数据结构前的我是这样认为的？！</em></strong></p>\n\n<p>什么是数据结构？数据结构要用什么语言实现？学了数据结构后能做什么？</p>\n\n<hr/></li>\n<li><p><strong><em>学习数据结构后的我有什么感触?</em></strong></p>\n\n<ul><li><p>数据结构是指相互之间存在着一种或多种关系的数据元素的<strong>集合</strong>和该集合中<strong>数据元素之间的关系</strong>组成。 <br/>\n记为：</p>\n\n<p><strong>Data_Structure=(D,R)</strong></p>\n\n<p>其中<strong>D</strong>是数据元素的<strong>集合</strong>，<strong>R</strong>是该集合中所有元素之间的<strong>关系的有限集合</strong>。</p></li>\n<li><p>数据结构是一种处理数据的思想；</p></li>\n<li><p>数据结构是一种处理数据的模型（计算机的本领就是处理数据的能力超强），可见数据结构的重要性！</p>\n\n<hr/></li></ul></li>\n</ul>\n\n\n\n<h3 id=\"学习过程总结\">学习过程总结</h3>\n\n<p><strong>学习技巧</strong>：</p>\n\n<pre><code>    **实践是检验真理的唯一标准，也是学习数据结构的唯一技巧**\n</code></pre>\n\n<p>文中所有的代码实现都使用了类模板，大家使用时可酌情选择！</p>\n\n<ul>\n<li><p><strong><em>第一夜：线性表</em></strong></p>\n\n<p><strong>线性结构</strong>：数据结构中的元素存在一对一的相互关系，</p>\n\n<p>线性表是N个数据元素的有限序列；</p>\n\n<ul><li>常用的线性结构有：线性表，栈，队列，双队列，数组，串。</li>\n<li>常见的非线性结构有：二维数组，多维数组，广义表，树(二叉树等)，图。</li>\n<li>在具体实现时，长度Length的概念贯穿在顺序表和链表中，非常有用；</li></ul>\n\n<p>以下主要总结了两种特例线性结构：顺序表和链表；</p></li>\n</ul>\n\n<p><strong>线性表之——顺序表篇</strong></p>\n\n<p>用基本数据类型—数组 去实现顺序表的增改删查的方法， <br/>\n话不多说，直接上源码解释；</p>\n\n<ol>\n<li>list.h   文件内容如下：</li>\n</ol>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs cpp\"><span class=\"hljs-comment\">/*\n    代码要求实现效果:建立一个顺序表存取一下序列：\n    1,3,5,7,9\n\n    对于线性表中的每一个元素，在该元素前的一个元素叫 前驱 ，\n    在该元素后的一个元素叫 后继 ，\n    第一个元素只有 后继，最后一个元素只有 前驱；\n*/</span>\n\n<span class=\"hljs-preprocessor\">#ifndef LIST_H</span>\n<span class=\"hljs-preprocessor\">#define LIST_H</span>\n\n<span class=\"hljs-comment\">/*\n#ifndef LIST_H \n#define LIST_H\n\n...\n\n#endif\n\n这样一段话的意思是 如果没有定义头文件的别名，就定义它\n\n他的作用是，如果有其他文件多次调用这个头文件，那么为了防止重复定义，加入\n\n判断语句，只有第一次会进行定义，当第一个定义后，其他的调用定义会忽略。\n*/</span>\n\n<span class=\"hljs-preprocessor\">#include &lt;iostream&gt;</span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;  <span class=\"hljs-comment\">// 定义类模板</span>\n<span class=\"hljs-keyword\">class</span> List\n{\n<span class=\"hljs-keyword\">public</span>:\n    List(<span class=\"hljs-keyword\">int</span> size); <span class=\"hljs-comment\">//构造函数，定义数组大小为size</span>\n    ~List();\n    <span class=\"hljs-keyword\">void</span> clearList();  <span class=\"hljs-comment\">//清空该顺序表</span>\n    <span class=\"hljs-keyword\">bool</span> listEmpty(); <span class=\"hljs-comment\">//用于判断该表是否为空，返回bool类型</span>\n    <span class=\"hljs-keyword\">int</span> listLength(); <span class=\"hljs-comment\">//用于检测数组（表）中以存元素的数量</span>\n    Datatype listGet(<span class=\"hljs-keyword\">int</span> i); <span class=\"hljs-comment\">//获取数组（表）中指定的索引的元素；</span>\n    <span class=\"hljs-keyword\">int</span> listLocate(Datatype x); <span class=\"hljs-comment\">//用于获取指定元素在数组中第一次出现位置的索引；</span>\n    Datatype Precursor(Datatype x); <span class=\"hljs-comment\">//获取指定元素的前驱；</span>\n    Datatype next(Datatype x); <span class=\"hljs-comment\">//获取指定元素的后驱</span>\n    <span class=\"hljs-keyword\">bool</span> listInsert(<span class=\"hljs-keyword\">int</span> i,Datatype x); <span class=\"hljs-comment\">//用于在索引为i的位置插入元素</span>\n    Datatype listDelete(<span class=\"hljs-keyword\">int</span> i); <span class=\"hljs-comment\">//用于删除索引为i的元素；</span>\n    <span class=\"hljs-keyword\">void</span> printList(); <span class=\"hljs-comment\">//遍历并打印出该顺序表；</span>\n<span class=\"hljs-keyword\">private</span>:\n    Datatype *p_List;  <span class=\"hljs-comment\">//定义表的指针变量</span>\n    <span class=\"hljs-keyword\">int</span> Size; <span class=\"hljs-comment\">// 用于初始化表的大小</span>\n    <span class=\"hljs-keyword\">int</span> Length; <span class=\"hljs-comment\">//存表所存元素的数量</span>\n};\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\nList&lt;Datatype&gt;::List( <span class=\"hljs-keyword\">int</span> size )\n{\n    Size = size; <span class=\"hljs-comment\">//有用户传入参数以定义表的大小；</span>\n    Length = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//长度初始化为0；</span>\n    p_List = <span class=\"hljs-keyword\">new</span> Datatype[Size]; <span class=\"hljs-comment\">//在堆中去申请一个数组用于实现顺序表（存数据）；</span>\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\nList&lt;Datatype&gt;::~List() <span class=\"hljs-comment\">//析构函数，用于整理申请的空间归仓；</span>\n{\n    <span class=\"hljs-keyword\">delete</span> []p_List;\n    p_List = NULL;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">void</span> List&lt;Datatype&gt;::clearList()\n{\n    Length = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 将表的元素个数置 0</span>\n    <span class=\"hljs-comment\">//(因为下面所有的操作都是基于元素长度来进行，</span>\n    <span class=\"hljs-comment\">//所以这里将长度置为0就相当于在清空表)</span>\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">bool</span> List&lt;Datatype&gt;::listEmpty()\n{   <span class=\"hljs-comment\">//这里很容易理解吧！</span>\n    <span class=\"hljs-keyword\">if</span> (Length == <span class=\"hljs-number\">0</span>)\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    } \n    <span class=\"hljs-keyword\">else</span>\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">int</span> List&lt;Datatype&gt;::listLength()\n{\n    <span class=\"hljs-keyword\">return</span> Length;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\nDatatype List&lt;Datatype&gt;::listGet( <span class=\"hljs-keyword\">int</span> i )\n{   \n    <span class=\"hljs-comment\">//遍历整个表去寻找；</span>\n    <span class=\"hljs-keyword\">try</span>\n    {\n        <span class=\"hljs-keyword\">if</span> (i&gt;=<span class=\"hljs-number\">0</span>&amp;&amp;i&lt;=Length)\n        {\n            <span class=\"hljs-keyword\">return</span> p_List[i];\n        }\n        <span class=\"hljs-keyword\">else</span>\n        {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">//所给元素越界，抛出错误!</span>\n        }\n    }\n\n    <span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-keyword\">int</span>) <span class=\"hljs-comment\">//捕捉错误；</span>\n    {\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"查找位置非法！\"</span>&lt;&lt;endl;\n    }\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">int</span> List&lt;Datatype&gt;::listLocate( Datatype x )\n{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;Length;j++) <span class=\"hljs-comment\">//遍历整个数组寻找</span>\n    {\n        <span class=\"hljs-keyword\">if</span> (x == p_List[j])\n        {\n            <span class=\"hljs-keyword\">return</span> j; <span class=\"hljs-comment\">//找到就返回元素的索引；</span>\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// 没找到就返回0；</span>\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\nDatatype List&lt;Datatype&gt;::Precursor( Datatype x )\n{\n    <span class=\"hljs-keyword\">try</span>\n    {\n        <span class=\"hljs-keyword\">int</span> temp = listLocate(x); <span class=\"hljs-comment\">//先定位到该元素；</span>\n        <span class=\"hljs-comment\">//若有所指的元素有前驱便返回前驱；</span>\n        <span class=\"hljs-keyword\">if</span> (temp!=<span class=\"hljs-number\">0</span> &amp;&amp; temp&gt;<span class=\"hljs-number\">0</span> &amp;&amp; temp&lt;=Length)\n        {\n            <span class=\"hljs-keyword\">return</span> p_List[temp-<span class=\"hljs-number\">1</span>];\n        } \n        <span class=\"hljs-keyword\">else</span>\n        {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-number\">1</span>;\n        }\n    }\n    <span class=\"hljs-keyword\">catch</span>(<span class=\"hljs-keyword\">int</span>)\n    {\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"该位置没有前驱！\"</span>&lt;&lt;endl;\n    }\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\nDatatype List&lt;Datatype&gt;::next( Datatype x )\n{\n    <span class=\"hljs-keyword\">try</span>\n    {\n    <span class=\"hljs-comment\">//写法类似于找前驱！</span>\n        <span class=\"hljs-keyword\">int</span> temp = listLocate(x);\n        <span class=\"hljs-keyword\">if</span> (temp&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; temp&lt;Length)\n        {\n            <span class=\"hljs-keyword\">return</span> p_List[temp+<span class=\"hljs-number\">1</span>];\n        } \n        <span class=\"hljs-keyword\">else</span>\n        {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-number\">1</span>;\n        }\n    }\n    <span class=\"hljs-keyword\">catch</span> (<span class=\"hljs-keyword\">int</span>)\n    {\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"该位置没有后驱！\"</span>&lt;&lt;endl;\n        <span class=\"hljs-comment\">//exit(1);</span>\n    }\n\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">bool</span> List&lt;Datatype&gt;::listInsert( <span class=\"hljs-keyword\">int</span> i,Datatype x )\n{\n<span class=\"hljs-comment\">//插入元素时必须把插入点后面的元素都往后移动一个位置</span>\n    <span class=\"hljs-keyword\">if</span> (i&lt;<span class=\"hljs-number\">0</span> || i&gt;Length) <span class=\"hljs-comment\">//判断位置合法性；</span>\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    } \n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> k=Length-<span class=\"hljs-number\">1</span>;k&gt;=i;k--) <span class=\"hljs-comment\">//从后往前遍历，已达到移位的效果；</span>\n    {\n        p_List[k+<span class=\"hljs-number\">1</span>] = p_List[k];\n    }\n    p_List[i] = x; <span class=\"hljs-comment\">//移动完毕，实施插入；</span>\n    Length++; <span class=\"hljs-comment\">// 长度+1</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>; <span class=\"hljs-comment\">//返回插入成功的信号（bool类型）</span>\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\nDatatype List&lt;Datatype&gt;::listDelete( <span class=\"hljs-keyword\">int</span> i)\n{\n<span class=\"hljs-comment\">//删除元素是，该元素之后的所有元素分别往前移动一位即可；</span>\n    <span class=\"hljs-keyword\">try</span>\n    {\n        <span class=\"hljs-keyword\">if</span> (i&lt;<span class=\"hljs-number\">0</span>||i&gt;Length) <span class=\"hljs-comment\">//判断i的合法性；</span>\n            {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-number\">1</span>;\n            }\n        Datatype temp;\n        temp = p_List[i]; <span class=\"hljs-comment\">//存下要删除的元素，以便于返回其值出来</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> k=i;k&lt;Length;k++)<span class=\"hljs-comment\">//从后往前遍历，已达到移位的效果；</span>\n        {\n            p_List[k] = p_List[k+<span class=\"hljs-number\">1</span>];\n        }\n        Length--;\n        <span class=\"hljs-keyword\">return</span> temp;\n    }   \n    <span class=\"hljs-keyword\">catch</span> (<span class=\"hljs-keyword\">int</span>)\n    {\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"删除位置非法!\"</span>&lt;&lt;endl;\n        <span class=\"hljs-comment\">//exit(1);</span>\n    }\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">void</span> List&lt;Datatype&gt;::printList()\n{\n<span class=\"hljs-comment\">//遍历输出表中所有元素；</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;Length;i++)\n    {\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt; p_List[i] &lt;&lt;endl;\n    }\n}\n\n<span class=\"hljs-preprocessor\">#endif</span></code></pre>\n\n<ol>\n<li>list.cpp 文件的类容如下：(测试代码)</li>\n</ol>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs cpp\"><span class=\"hljs-preprocessor\">#include \"list.h\"</span>\n<span class=\"hljs-preprocessor\">#include &lt;iostream&gt;</span>\n<span class=\"hljs-preprocessor\">#include \"Coordinate.h\"</span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-keyword\">int</span> main()\n{\n\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-built_in\">list</span>.listEmpty()&lt;&lt;endl;\n\n    <span class=\"hljs-keyword\">int</span> num[<span class=\"hljs-number\">5</span>] = {<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">5</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">9</span>};\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;<span class=\"hljs-number\">5</span>;i++)\n    {\n        <span class=\"hljs-built_in\">list</span>.listInsert(i,num[i]);\n    }\n    <span class=\"hljs-built_in\">list</span>.printList();\n\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt; <span class=\"hljs-built_in\">list</span>.listLength()&lt;&lt;endl;\n\n    <span class=\"hljs-keyword\">int</span> m,n;\n    m = <span class=\"hljs-built_in\">list</span>.listDelete(<span class=\"hljs-number\">4</span>);\n    n = <span class=\"hljs-built_in\">list</span>.listDelete(<span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt; m &lt;&lt;endl;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt; n &lt;&lt;endl;\n    <span class=\"hljs-built_in\">list</span>.listLength();\n\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-built_in\">list</span>.listGet(<span class=\"hljs-number\">1</span>)&lt;&lt;endl;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-built_in\">list</span>.Precursor(<span class=\"hljs-number\">5</span>)&lt;&lt;endl;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-built_in\">list</span>.next(<span class=\"hljs-number\">3</span>)&lt;&lt;endl;\n\n    <span class=\"hljs-built_in\">list</span>.clearList();\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-built_in\">list</span>.listLength()&lt;&lt;endl;\n    <span class=\"hljs-built_in\">list</span>.listDelete(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-built_in\">list</span>.listLength()&lt;&lt;endl;\n    <span class=\"hljs-built_in\">list</span>.Precursor(<span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-built_in\">list</span>.printList();\n\n    system(<span class=\"hljs-string\">\"pause\"</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n\n<ol>\n<li>用刚实现的顺序表存 点 类型的数据，下面为 点 类型的类的代码，包括相关运算符的重载； <br/>\n下面为 coordinate.h 文件的源码：</li>\n</ol>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs cs\"><span class=\"hljs-preprocessor\">#ifndef COORDINATE_H</span>\n<span class=\"hljs-preprocessor\">#<span class=\"hljs-keyword\">define</span> COORDINATE_H</span>\n\n<span class=\"hljs-preprocessor\">#include &lt;iostream&gt;</span>\n<span class=\"hljs-preprocessor\">#include &lt;ostream&gt;</span>\n\n<span class=\"hljs-keyword\">using</span> namespace std;\n\nclass Coordinate\n{\n    <span class=\"hljs-comment\">//声明输出重载函数为友元函数；</span>\n    friend ostream &amp;<span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream &amp;<span class=\"hljs-keyword\">out</span>,Coordinate &amp;coor); \n<span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-title\">Coordinate</span>(<span class=\"hljs-keyword\">int</span> x=<span class=\"hljs-number\">0</span>,<span class=\"hljs-keyword\">int</span> y=<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">//含默认参数的构造函数；</span>\n    ~Coordinate(){};\n    <span class=\"hljs-keyword\">void</span> printCoordinate(); <span class=\"hljs-comment\">// 打印出 点 ；</span>\n    <span class=\"hljs-keyword\">bool</span> <span class=\"hljs-keyword\">operator</span>==(Coordinate &amp;coor); <span class=\"hljs-comment\">//重载用算符 == </span>\n\n<span class=\"hljs-keyword\">protected</span>:\n    <span class=\"hljs-keyword\">int</span> X;\n    <span class=\"hljs-keyword\">int</span> Y;\n};\n\nCoordinate::Coordinate( <span class=\"hljs-keyword\">int</span> x<span class=\"hljs-comment\">/*=0*/</span>,<span class=\"hljs-keyword\">int</span> y<span class=\"hljs-comment\">/*=0*/</span> )\n{\n    X = x;\n    Y = y;\n}\n\n<span class=\"hljs-keyword\">void</span> Coordinate::printCoordinate()\n{\n    cout&lt;&lt; <span class=\"hljs-string\">\"(\"</span> &lt;&lt; X &lt;&lt; <span class=\"hljs-string\">','</span> &lt;&lt; Y &lt;&lt; <span class=\"hljs-string\">\")\"</span> &lt;&lt;endl;\n}\n\nostream &amp;<span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream &amp;<span class=\"hljs-keyword\">out</span>,Coordinate &amp;coor)\n{\n    <span class=\"hljs-keyword\">out</span>&lt;&lt; <span class=\"hljs-string\">\"(\"</span> &lt;&lt; coor.X &lt;&lt; <span class=\"hljs-string\">','</span> &lt;&lt; coor.Y &lt;&lt; <span class=\"hljs-string\">\")\"</span> &lt;&lt;endl;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">out</span>;\n}\n\n\n<span class=\"hljs-keyword\">bool</span> Coordinate::<span class=\"hljs-keyword\">operator</span>==( Coordinate &amp;coor )\n{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>-&gt;X == coor.X &amp;&amp; <span class=\"hljs-keyword\">this</span>-&gt;Y == coor.Y)\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    } \n    <span class=\"hljs-keyword\">else</span>\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n}\n\n\n<span class=\"hljs-preprocessor\">#<span class=\"hljs-keyword\">endif</span></span></code></pre>\n\n<p>以下为coordinate类的测试源码：</p>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs cpp\"><span class=\"hljs-preprocessor\">#include \"list.h\"</span>\n<span class=\"hljs-preprocessor\">#include &lt;iostream&gt;</span>\n<span class=\"hljs-preprocessor\">#include \"Coordinate.h\"</span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-keyword\">int</span> main()\n{\n\n    List&lt;Coordinate&gt; <span class=\"hljs-built_in\">list</span>(<span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-built_in\">list</span>.listEmpty()&lt;&lt;endl;\n    <span class=\"hljs-comment\">/*\n    int num[5] = {1,3,5,7,9};\n    for (int i=0;i&lt;5;i++)\n    {\n        list.listInsert(i,num[i]);\n    }\n    list.printList();\n\n    cout&lt;&lt; list.listLength()&lt;&lt;endl;\n\n    int m,n;\n    m = list.listDelete(4);\n    n = list.listDelete(0);\n    cout&lt;&lt; m &lt;&lt;endl;\n    cout&lt;&lt; n &lt;&lt;endl;\n    list.listLength();\n\n    cout&lt;&lt;list.listGet(1)&lt;&lt;endl;\n    cout&lt;&lt;list.Precursor(5)&lt;&lt;endl;\n    cout&lt;&lt;list.next(3)&lt;&lt;endl;\n\n    list.clearList();\n    cout&lt;&lt;list.listLength()&lt;&lt;endl;\n    //list.listDelete(1);\n    //cout&lt;&lt;list.listLength()&lt;&lt;endl;\n    //list.Precursor(1);\n    */</span>\n\n    Coordinate e1(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>);\n    Coordinate e2(<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">2</span>);\n    Coordinate e3(<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">3</span>);\n    Coordinate e4(<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">4</span>);\n\n    <span class=\"hljs-built_in\">list</span>.listInsert(<span class=\"hljs-number\">0</span>,e1);\n    <span class=\"hljs-built_in\">list</span>.listInsert(<span class=\"hljs-number\">1</span>,e2);\n    <span class=\"hljs-built_in\">list</span>.listInsert(<span class=\"hljs-number\">2</span>,e3);\n    <span class=\"hljs-built_in\">list</span>.listInsert(<span class=\"hljs-number\">3</span>,e4);\n\n    <span class=\"hljs-built_in\">list</span>.printList();\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-built_in\">list</span>.listLocate(e3)&lt;&lt;endl;\n\n    system(<span class=\"hljs-string\">\"pause\"</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n</code></pre>\n\n<hr/>\n\n<p><strong><em>线性表之——链表篇</em></strong></p>\n\n<p>自我总结C++实现链表的思想在于用next指针把每一个节点类（结构体）串连起来，你可以想象一条链条…：</p>\n\n<ol>\n<li><p>节点类的实现：</p>\n\n<p>链表中每一个节点有两大特征：存数据的DATA + next指针；所以除了头结点外的每一个节点的地址都必须从上一个节点那里获取，也就是必须通过上一个节点的next来指向下一个节点，以此方法来对节点的访问；另外还有一点需要特别注意的是，<strong>头结点是不存数据的！</strong></p>\n\n<p>Node.h 文件的内容 上源码：</p></li>\n</ol>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs cpp\"><span class=\"hljs-preprocessor\">#ifndef NODE_H</span>\n<span class=\"hljs-preprocessor\">#define NODE_H</span>\n\n\n<span class=\"hljs-preprocessor\">#include &lt;iostream&gt;</span>\n\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">class</span> Node\n{\n<span class=\"hljs-keyword\">public</span>:\n    T data; <span class=\"hljs-comment\">//定义一个模板类的数据域;</span>\n    Node *next; <span class=\"hljs-comment\">//定义一个指针域;</span>\n    <span class=\"hljs-keyword\">void</span> printNode(); <span class=\"hljs-comment\">//打印节点数据</span>\n};\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">void</span> Node&lt;T&gt;::printNode()\n{\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt; data &lt;&lt;endl;\n}\n\n<span class=\"hljs-preprocessor\">#endif</span></code></pre>\n\n<ol>\n<li><p>用LinkList类将各节点串连起来，并实现对链表中节点的增、改、删、查的功能以及扩充的功能；</p>\n\n<p>LinkList.h 文件的内容如下：</p></li>\n</ol>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs cpp\"><span class=\"hljs-preprocessor\">#ifndef LINKLIST_H</span>\n<span class=\"hljs-preprocessor\">#define  LINKLIST_H</span>\n\n<span class=\"hljs-preprocessor\">#include \"Node.h\"</span>\n<span class=\"hljs-preprocessor\">#include &lt;string&gt;</span>\n<span class=\"hljs-preprocessor\">#include &lt;iostream&gt;</span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-comment\">//可参见顺序表的类声明</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">class</span> LinkList\n{\n\n<span class=\"hljs-keyword\">public</span>:\n    LinkList(); <span class=\"hljs-comment\">//链表在创建时可以从堆中去申请到一块空间所以不用赋初值;</span>\n    ~LinkList();\n    <span class=\"hljs-keyword\">void</span> ClearList();\n    <span class=\"hljs-keyword\">bool</span> ListEmpty();\n    <span class=\"hljs-keyword\">int</span> ListLength();\n    <span class=\"hljs-keyword\">int</span> LocateElement( Node&lt;T&gt; *pNode );\n    <span class=\"hljs-keyword\">bool</span> PriorElement( Node&lt;T&gt; *pCurrentNode,Node&lt;T&gt; *pPreNode );\n    <span class=\"hljs-keyword\">bool</span> NexitElement( Node&lt;T&gt; *pCurrentNode,Node&lt;T&gt; *pNextNode );\n    <span class=\"hljs-keyword\">void</span> ListTraverse();\n    <span class=\"hljs-keyword\">bool</span> ListInsertHead( Node&lt;T&gt; *pNode );\n    <span class=\"hljs-keyword\">bool</span> ListInsertTail( Node&lt;T&gt; *pNode );\n    <span class=\"hljs-keyword\">bool</span> ListInsert( <span class=\"hljs-keyword\">int</span> i,Node&lt;T&gt; *pNode );\n    <span class=\"hljs-keyword\">bool</span> ListDelete( <span class=\"hljs-keyword\">int</span> i,Node&lt;T&gt; *pNode );\n    <span class=\"hljs-keyword\">bool</span> GetElement( <span class=\"hljs-keyword\">int</span> i,Node&lt;T&gt; *pNode );\n<span class=\"hljs-keyword\">private</span>:\n    Node&lt;T&gt; *p_List; <span class=\"hljs-comment\">//定义头结点;</span>\n    <span class=\"hljs-keyword\">int</span> Length;\n};\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\nLinkList&lt;T&gt;::LinkList()\n{\n    p_List = <span class=\"hljs-keyword\">new</span> Node&lt;T&gt;; <span class=\"hljs-comment\">//重堆中申请一个内存空间给头结点；</span>\n    Length = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-comment\">//p_List-&gt;data = NULL;</span>\n    p_List-&gt;next = NULL;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">void</span> LinkList&lt;T&gt;::ClearList()\n{\n<span class=\"hljs-comment\">//思想是从头结点开始，从上一个节点的next指针去找到下一个节点的地址再删除，直到最后一个节点；</span>\n    Node&lt;T&gt; *currentNode = p_List-&gt;next;\n    <span class=\"hljs-keyword\">while</span>(currentNode != NULL) <span class=\"hljs-comment\">//用审犯人，交代下线的方式来理解就很容易;</span>\n    {\n        Node&lt;T&gt; *temp = currentNode-&gt;next;\n        <span class=\"hljs-keyword\">delete</span> currentNode;\n        currentNode  = temp;\n    }\n    p_List-&gt;next = NULL;  <span class=\"hljs-comment\">//将头节点的next置空;</span>\n    Length = <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\nLinkList&lt;T&gt;::~LinkList()\n{\n    ClearList();\n    <span class=\"hljs-keyword\">delete</span> p_List;\n    p_List = NULL;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">bool</span> LinkList&lt;T&gt;::ListEmpty()\n{\n    <span class=\"hljs-keyword\">if</span> (Length == <span class=\"hljs-number\">0</span>)\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    }\n    <span class=\"hljs-keyword\">else</span>\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">int</span> LinkList&lt;T&gt;::ListLength()\n{\n    <span class=\"hljs-keyword\">return</span> Length;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-comment\">//先定义插入操作后，后面方法定义更容易理解;</span>\n<span class=\"hljs-keyword\">bool</span> LinkList&lt;T&gt;::ListInsertHead( Node&lt;T&gt; *pNode )\n{\n    Node&lt;T&gt; *temp = p_List-&gt;next; <span class=\"hljs-comment\">//从头节点的下一个节点的地址 //首先保存头结点的指针域;</span>\n    Node&lt;T&gt; *newNode = <span class=\"hljs-keyword\">new</span> Node&lt;T&gt;; <span class=\"hljs-comment\">//创建一个新节点;</span>\n    <span class=\"hljs-keyword\">if</span> (newNode == NULL) <span class=\"hljs-comment\">//判断申请内存是否失败；</span>\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n    newNode-&gt;data = pNode-&gt;data;  <span class=\"hljs-comment\">//将传入的节点数据传给新节点</span>\n    newNode-&gt;next = temp; <span class=\"hljs-comment\">//把新节点作为下一个节点</span>\n    p_List-&gt;next = newNode;  <span class=\"hljs-comment\">//这两步为连接操作;</span>\n    Length++;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">bool</span> LinkList&lt;T&gt;::ListInsertTail( Node&lt;T&gt; *pNode )\n{\n    Node&lt;T&gt;* currentNode = p_List; <span class=\"hljs-comment\">//从头节点开始访问；</span>\n    <span class=\"hljs-keyword\">while</span>(currentNode-&gt;next != NULL)\n    {\n        currentNode = currentNode-&gt;next;\n    }\n    Node&lt;T&gt; *newNode = <span class=\"hljs-keyword\">new</span> Node&lt;T&gt;;\n    <span class=\"hljs-keyword\">if</span> (newNode == NULL)\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n    newNode-&gt;data = pNode-&gt;data; <span class=\"hljs-comment\">//将传入的节点的数据保存到新节点</span>\n    <span class=\"hljs-comment\">//currentNode-&gt;next = newNode;</span>\n    newNode-&gt;next = NULL; <span class=\"hljs-comment\">//将新节点作为最后一个节点；</span>\n    currentNode-&gt;next = newNode; <span class=\"hljs-comment\">//连接操作</span>\n    Length++;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">bool</span> LinkList&lt;T&gt;::ListInsert( <span class=\"hljs-keyword\">int</span> i,Node&lt;T&gt; *pNode )\n{\n    <span class=\"hljs-keyword\">if</span> (i&lt;<span class=\"hljs-number\">0</span> || i&gt;Length)\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n    <span class=\"hljs-keyword\">else</span>\n    {\n        Node&lt;T&gt; *currentNode = p_List; <span class=\"hljs-comment\">//获取头结点，以便于遍历寻找下一个节点;</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">0</span>;k&lt;i;k++)\n        {\n            currentNode = currentNode-&gt;next;\n        }\n        Node&lt;T&gt; *newNode = <span class=\"hljs-keyword\">new</span> Node&lt;T&gt;;\n        <span class=\"hljs-keyword\">if</span> (newNode == NULL)\n        {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n        }\n        newNode-&gt;data = pNode-&gt;data;\n        newNode-&gt;next = currentNode-&gt;next;<span class=\"hljs-comment\">//使之前的下一个元素与新的元素相连;</span>\n        currentNode-&gt;next = newNode;\n        Length++;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    }\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">bool</span> LinkList&lt;T&gt;::ListDelete( <span class=\"hljs-keyword\">int</span> i,Node&lt;T&gt; *pNode )\n{\n    <span class=\"hljs-keyword\">if</span>(i&lt;<span class=\"hljs-number\">0</span> || i&gt;=Length)\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n    Node&lt;T&gt; *currentNode = p_List;\n    Node&lt;T&gt; *currentNodeBefore = NULL;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">0</span>;k&lt;=i;k++)\n    {\n        currentNodeBefore = currentNode; <span class=\"hljs-comment\">//将当前节点的首地址保存下来，;</span>\n        currentNode = currentNode-&gt;next;        <span class=\"hljs-comment\">//保持与之前元素的连接;</span>\n    }\n    currentNodeBefore-&gt;next = currentNode-&gt;next; <span class=\"hljs-comment\">//删除i所示元素的下一个元素，即目标元素；</span>\n    pNode-&gt;data = currentNode-&gt;data;\n    <span class=\"hljs-keyword\">delete</span> currentNode;\n    currentNode = NULL;\n    Length--;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">bool</span> LinkList&lt;T&gt;::GetElement( <span class=\"hljs-keyword\">int</span> i,Node&lt;T&gt; *pNode )\n{\n<span class=\"hljs-comment\">//获取指定位置的元素，将其传出来；</span>\n    <span class=\"hljs-keyword\">if</span> (i&lt;<span class=\"hljs-number\">0</span> || i&gt;Length)\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n    Node&lt;T&gt; * currentNode = p_List;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">0</span>;k&lt;=i;k++)\n    {\n        currentNode = currentNode-&gt;next;\n    }\n    pNode-&gt;data = currentNode-&gt;data;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">int</span> LinkList&lt;T&gt;::LocateElement( Node&lt;T&gt; *pNode )\n{\n    Node&lt;T&gt; *currentNode = p_List;\n    <span class=\"hljs-keyword\">int</span> count = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//头结点不存数据，应从头结点的next元素开始算;</span>\n    <span class=\"hljs-keyword\">while</span>(currentNode != NULL)\n    {\n        currentNode = currentNode-&gt;next;\n        <span class=\"hljs-comment\">//改注释的代码块为下面的通讯录Damon的，执行通讯录时请将下面的if语句替换掉</span>\n        <span class=\"hljs-comment\">//if (pNode-&gt;data == currentNode-&gt;data)</span>\n        <span class=\"hljs-comment\">//{</span>\n        <span class=\"hljs-comment\">//  return count;</span>\n        <span class=\"hljs-comment\">//}</span>\n\n        <span class=\"hljs-keyword\">if</span> (pNode-&gt;data == currentNode-&gt;data)\n        {\n            <span class=\"hljs-keyword\">return</span> count;\n        }\n        <span class=\"hljs-keyword\">else</span>\n        {\n            <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n        }\n        count++;\n    }\n    <span class=\"hljs-comment\">//cout&lt;&lt; \"该链表中没有该元素！\"&lt;&lt;endl;</span>\n    <span class=\"hljs-comment\">//return -1;</span>\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">bool</span> LinkList&lt;T&gt;::PriorElement( Node&lt;T&gt; *pCurrentNode,Node&lt;T&gt; *pPreNode )\n{\n    Node&lt;T&gt; *currentNode = p_List;\n    Node&lt;T&gt; *tempNode = NULL;\n    <span class=\"hljs-keyword\">while</span>(currentNode =! NULL)\n    {\n        tempNode = currentNode;\n        currentNode = currentNode-&gt;next;\n        <span class=\"hljs-keyword\">if</span> (currentNode-&gt;data == pCurrentNode-&gt;data)\n        {\n            <span class=\"hljs-keyword\">if</span> (tempNode == p_List)\n            {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n            } \n            <span class=\"hljs-keyword\">else</span>\n            {\n                pPreNode-&gt;data = tempNode-&gt;data;\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n            }\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">bool</span> LinkList&lt;T&gt;::NexitElement( Node&lt;T&gt; *pCurrentNode,Node&lt;T&gt; *pNextNode )\n{\n    Node&lt;T&gt; *currentNode = p_List;\n    <span class=\"hljs-keyword\">while</span>(currentNode =! NULL)\n    {\n        currentNode = currentNode-&gt;next;\n        <span class=\"hljs-keyword\">if</span> (currentNode.data == pCurrentNode-&gt;data)\n        {\n            <span class=\"hljs-keyword\">if</span> (currentNode-&gt;next == NULL)\n            {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n            } \n            <span class=\"hljs-keyword\">else</span>\n            {\n                pNextNode-&gt;data = currentNode-&gt;next-&gt;data; <span class=\"hljs-comment\">//头结点不算元素;</span>\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n            }\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">void</span> LinkList&lt;T&gt;::ListTraverse()\n{\n    <span class=\"hljs-keyword\">if</span> ( Length == <span class=\"hljs-number\">0</span>)\n    {\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"error\"</span>&lt;&lt;endl;\n        <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);\n    }\n    Node&lt;T&gt; *currentNode = p_List;\n    <span class=\"hljs-keyword\">while</span>(currentNode-&gt;next != NULL)\n    {\n        currentNode = currentNode-&gt;next;\n        currentNode-&gt;printNode();\n    }\n}\n\n<span class=\"hljs-preprocessor\">#endif</span></code></pre>\n\n<ol>\n<li><p>用刚才实现的链表打造一个 通讯录 ；</p>\n\n<ul><li>首先得写一个people类用于存每个人的信息；</li>\n<li>利用链表的数据结构将people类的数据组织起来，以便于增改删查功能；</li></ul></li>\n</ol>\n\n<p>i. 写出people类，people.h 的源码如下：</p>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs cs\"><span class=\"hljs-preprocessor\">#ifndef PERSON_H</span>\n<span class=\"hljs-preprocessor\">#<span class=\"hljs-keyword\">define</span> PERSON_H</span>\n\n<span class=\"hljs-preprocessor\">#include &lt;string&gt;</span>\n<span class=\"hljs-preprocessor\">#include &lt;ostream&gt;</span>\n\n<span class=\"hljs-keyword\">using</span> namespace std;\n\n\nclass Person\n{\n    friend ostream &amp;<span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream &amp;<span class=\"hljs-keyword\">out</span>,Person &amp;person); <span class=\"hljs-comment\">//声明友元函数用于重载输出运算符；</span>\n<span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-keyword\">string</span> name; <span class=\"hljs-comment\">//用于存联系人名字；</span>\n    <span class=\"hljs-keyword\">string</span> phone; <span class=\"hljs-comment\">//用于存联系人电话；</span>\n    <span class=\"hljs-comment\">//int age;</span>\n    Person &amp;<span class=\"hljs-keyword\">operator</span>=(Person &amp;person); <span class=\"hljs-comment\">//重载比较运算符</span>\n    <span class=\"hljs-keyword\">bool</span> <span class=\"hljs-keyword\">operator</span>==(Person &amp;person); <span class=\"hljs-comment\">//重载==运算符</span>\n};\n\nostream &amp;<span class=\"hljs-keyword\">operator</span>&lt;&lt;(ostream &amp;<span class=\"hljs-keyword\">out</span>,Person &amp;person)\n{\n    <span class=\"hljs-keyword\">out</span> &lt;&lt; person.name &lt;&lt; <span class=\"hljs-string\">\"-------\"</span> &lt;&lt; person.phone &lt;&lt;endl;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">out</span>;\n}\n\nPerson &amp; Person::<span class=\"hljs-keyword\">operator</span>=( Person &amp;person )\n{\n    <span class=\"hljs-keyword\">this</span>-&gt;name = person.name;\n    <span class=\"hljs-comment\">//this-&gt;age = person.age;</span>\n    <span class=\"hljs-keyword\">this</span>-&gt;phone = person.phone;\n    <span class=\"hljs-keyword\">return</span> *<span class=\"hljs-keyword\">this</span>;\n}\n\n<span class=\"hljs-keyword\">bool</span> Person::<span class=\"hljs-keyword\">operator</span>==( Person &amp;person )\n{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>-&gt;name == person.name &amp;&amp; <span class=\"hljs-keyword\">this</span>-&gt;phone == person.phone)\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    } \n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n}\n\n<span class=\"hljs-preprocessor\">#<span class=\"hljs-keyword\">endif</span></span></code></pre>\n\n<p>j. LinkList.cpp 文件的内容如下：</p>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs cpp\"><span class=\"hljs-preprocessor\">#include \"LinkList.h\"</span>\n<span class=\"hljs-preprocessor\">#include \"Person.h\"</span>\n<span class=\"hljs-comment\">//#include \"Node.h\"</span>\n<span class=\"hljs-preprocessor\">#include &lt;iostream&gt;</span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n\n<span class=\"hljs-keyword\">int</span> menu()\n{\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;endl;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"---------功能表---------\"</span>&lt;&lt;endl;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"------1.新建联系人------\"</span>&lt;&lt;endl;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"------2.删除联系人------\"</span>&lt;&lt;endl;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"------3.查询联系人------\"</span>&lt;&lt;endl;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"------4.浏览联系人------\"</span>&lt;&lt;endl;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"------5.退出通讯录------\"</span>&lt;&lt;endl;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;endl;\n    <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt; <span class=\"hljs-string\">\"请选择功能:\"</span> &lt;&lt;endl;\n    <span class=\"hljs-built_in\">cin</span>&gt;&gt; n ;\n    <span class=\"hljs-keyword\">if</span> (n&lt;<span class=\"hljs-number\">0</span> || n&gt;<span class=\"hljs-number\">5</span>)\n    {\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt; <span class=\"hljs-string\">\"选择功能未开发......请重选！\"</span>&lt;&lt;endl;\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt; <span class=\"hljs-string\">\"请选择功能:\"</span> &lt;&lt;endl;\n        menu();\n    }\n    <span class=\"hljs-keyword\">return</span> n;\n}\n\n<span class=\"hljs-keyword\">void</span> createPerson(LinkList&lt;Person&gt; *<span class=\"hljs-built_in\">list</span>) \n{\n    Node&lt;Person&gt; node;\n    Person person;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"请输入新建联系人信息：\"</span>&lt;&lt;endl;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"姓名： \"</span>;\n    <span class=\"hljs-built_in\">cin</span>&gt;&gt;person.name;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"电话： \"</span>;\n    <span class=\"hljs-built_in\">cin</span>&gt;&gt;person.phone;\n    node.data = person;\n    <span class=\"hljs-built_in\">list</span>-&gt;ListInsertTail(&amp;node);\n}\n\n<span class=\"hljs-keyword\">void</span> deletePerson(LinkList&lt;Person&gt; *<span class=\"hljs-built_in\">list</span>) \n{\n    Node&lt;Person&gt; node1,node2;\n    Person person;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"请输入需要删除的联系人信息：\"</span>&lt;&lt;endl;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"姓名： \"</span>;\n    <span class=\"hljs-built_in\">cin</span>&gt;&gt;person.name;\n    node1.data = person;\n    <span class=\"hljs-keyword\">int</span> locate_i;\n    locate_i = <span class=\"hljs-built_in\">list</span>-&gt;LocateElement(&amp;node1);\n    <span class=\"hljs-keyword\">if</span> (locate_i != -<span class=\"hljs-number\">1</span>)\n    {\n        <span class=\"hljs-built_in\">list</span>-&gt;ListDelete(locate_i,&amp;node2);\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"删除成功！\"</span>&lt;&lt;endl;\n        <span class=\"hljs-keyword\">return</span> ;\n    }\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"您的通讯录里没有这个人，请重选功能！\"</span>&lt;&lt;endl;\n    <span class=\"hljs-keyword\">return</span> ;\n}\n\n<span class=\"hljs-keyword\">void</span> selectPerson( LinkList&lt;Person&gt;* <span class=\"hljs-built_in\">list</span> ) \n{\n    Node&lt;Person&gt; node1,node2;\n    Person person;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"请输入所查联系人的信息：\"</span>&lt;&lt;endl;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"姓名： \"</span>;\n    <span class=\"hljs-built_in\">cin</span>&gt;&gt;person.name;\n    node1.data = person;\n    <span class=\"hljs-keyword\">int</span> locate_i;\n    locate_i = <span class=\"hljs-built_in\">list</span>-&gt;LocateElement(&amp;node1);\n    <span class=\"hljs-keyword\">if</span> (locate_i != -<span class=\"hljs-number\">1</span>)\n    {\n        <span class=\"hljs-built_in\">list</span>-&gt;GetElement(locate_i,&amp;node2);\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"查询结果如下：\"</span>&lt;&lt;endl;\n        node2.printNode();\n        <span class=\"hljs-keyword\">return</span> ;\n    }\n    <span class=\"hljs-keyword\">else</span>\n    {\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt; <span class=\"hljs-string\">\"您的通讯录里没有该联系人！\"</span>&lt;&lt;endl;\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"请重选功能\"</span>&lt;&lt;endl;\n        <span class=\"hljs-keyword\">return</span> ;\n    }\n}\n\n<span class=\"hljs-keyword\">void</span> allPerson( LinkList&lt;Person&gt;* <span class=\"hljs-built_in\">list</span> ) \n{\n    <span class=\"hljs-built_in\">list</span>-&gt;ListTraverse();\n}\n\n<span class=\"hljs-keyword\">int</span> main()\n{\n    LinkList&lt;Person&gt; <span class=\"hljs-built_in\">list</span>;\n    <span class=\"hljs-keyword\">int</span> select = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">while</span>(select != <span class=\"hljs-number\">5</span>)\n    {\n        select = menu();\n        <span class=\"hljs-keyword\">switch</span> (select)\n        {\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>:\n            <span class=\"hljs-built_in\">cout</span>&lt;&lt; <span class=\"hljs-string\">\"用户指令---&gt;&gt;新建联系人：\"</span>&lt;&lt;endl;\n            createPerson(&amp;<span class=\"hljs-built_in\">list</span>);\n            <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"新建成功！\"</span>&lt;&lt;endl;\n            <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">2</span>:\n            <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"用户指令---&gt;&gt;删除联系人： \"</span>&lt;&lt;endl;\n            deletePerson(&amp;<span class=\"hljs-built_in\">list</span>);\n            <span class=\"hljs-comment\">//cout&lt;&lt;\"删除成功！\"&lt;&lt;endl;</span>\n            <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">3</span>:\n            <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"用户指令---&gt;&gt;查询联系人： \"</span>&lt;&lt;endl;\n            selectPerson(&amp;<span class=\"hljs-built_in\">list</span>);\n            <span class=\"hljs-comment\">//cout&lt;&lt;\"查询成功！\"&lt;&lt;endl;</span>\n            <span class=\"hljs-keyword\">break</span>;\n        <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">4</span>:\n            <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"用户指令---&gt;&gt;浏览联系人： \"</span>&lt;&lt;endl;\n            allPerson(&amp;<span class=\"hljs-built_in\">list</span>);\n            <span class=\"hljs-comment\">//cout&lt;&lt;\"浏览成功！\"&lt;&lt;endl;</span>\n        }\n    }\n    <span class=\"hljs-built_in\">exit</span>(<span class=\"hljs-number\">1</span>);\n\n    system(<span class=\"hljs-string\">\"pause\"</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n\n<p>一个通过链表来实现的简易通讯录就这样实现了，作为一名程 <br/>\n序猿来说，此时的心情是谈10个女朋友也无法比拟的。真是美 <br/>\n滋滋啊<del>~</del>~~~~</p>\n\n<hr/>\n\n<ul>\n<li><p><strong><em>第二夜：数据结构之——队列篇；</em></strong></p>\n\n<p><strong>队列</strong>：队列是一种特殊的线性表，特殊之处在于它只 <br/>\n允许在表的前端（front）进行删除操作，而在表的后端（ <br/>\nrear）进行插入操作，和栈一样，队列是一种操作受限制 <br/>\n的线性表。 <br/>\n简言之就是一种先进先出（FIFO）的数据模型；可以理解 <br/>\n为一队人在买票，先来者站前面，先买好就先走，后来的 <br/>\n站后面，从前往后买；排在最前面的称作队头，最后面的 <br/>\n称为队尾！</p>\n\n<ol><li>这里直接实现了环形队列，CirQueue.h 的源码如下：</li></ol></li>\n</ul>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs cpp\"><span class=\"hljs-preprocessor\">#ifndef CIRQUEUE_H</span>\n<span class=\"hljs-preprocessor\">#define CIRQUEUE_H</span>\n\n<span class=\"hljs-preprocessor\">#include &lt;iostream&gt;</span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-comment\">//const int CirQueueSize = 4;</span>\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt; <span class=\"hljs-comment\">//定义类模板；</span>\n\n<span class=\"hljs-keyword\">class</span> CirQueue\n{\n    <span class=\"hljs-keyword\">public</span>:\n        CirQueue(<span class=\"hljs-keyword\">int</span> CirQueueSize); <span class=\"hljs-comment\">//构造函数</span>\n        <span class=\"hljs-keyword\">virtual</span> ~CirQueue();\n        <span class=\"hljs-keyword\">void</span> ClearQueue(); <span class=\"hljs-comment\">//清除队列；</span>\n        <span class=\"hljs-keyword\">void</span> QueueTraverse(); <span class=\"hljs-comment\">//遍历队列；</span>\n        <span class=\"hljs-keyword\">bool</span> QueueEmpty(); <span class=\"hljs-comment\">//判空；</span>\n        <span class=\"hljs-keyword\">bool</span> QueueFull(); <span class=\"hljs-comment\">//判满；</span>\n        <span class=\"hljs-keyword\">int</span> QueueLength();\n        <span class=\"hljs-keyword\">bool</span> EnQueue(Datatype x); <span class=\"hljs-comment\">//入队</span>\n        <span class=\"hljs-keyword\">bool</span> DeQueue(Datatype &amp;x);<span class=\"hljs-comment\">//出队；</span>\n        Datatype GetQueue(); <span class=\"hljs-comment\">//获取队头不出队；</span>\n    <span class=\"hljs-keyword\">private</span>:\n        <span class=\"hljs-keyword\">int</span> *p_Queue; <span class=\"hljs-comment\">//队列（数组）的指针</span>\n        <span class=\"hljs-keyword\">int</span> QueueSize; <span class=\"hljs-comment\">//容器（数组）的大小；</span>\n        <span class=\"hljs-keyword\">int</span> Length; <span class=\"hljs-comment\">//队列的长度；</span>\n        <span class=\"hljs-keyword\">int</span> Head; <span class=\"hljs-comment\">//队头</span>\n        <span class=\"hljs-keyword\">int</span> Teal; <span class=\"hljs-comment\">//队尾</span>\n};\n\n\n<span class=\"hljs-comment\">//const int CirQueueSize = 4;</span>\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\nCirQueue&lt;Datatype&gt;::CirQueue(<span class=\"hljs-keyword\">int</span> CirQueueSize)\n{\n    QueueSize = CirQueueSize;\n    <span class=\"hljs-keyword\">try</span>\n    {\n        p_Queue = <span class=\"hljs-keyword\">new</span> Datatype[QueueSize]; <span class=\"hljs-comment\">//在堆区申请一个数组用作队列元素的容器；</span>\n    }\n\n    <span class=\"hljs-keyword\">catch</span>(...)\n    {\n        <span class=\"hljs-keyword\">delete</span> []p_Queue;\n        p_Queue = NULL;\n        <span class=\"hljs-comment\">//cout&lt;&lt; \"队列创建失败，请重试！\" &lt;&lt;endl;</span>\n    }\n\n    Head = Teal =QueueSize-<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">//队列开始时队头与队尾指针都指在同一位置；</span>\n    Length = <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\nCirQueue&lt;Datatype&gt;::~CirQueue()\n{\n    <span class=\"hljs-keyword\">delete</span> []p_Queue;\n    p_Queue = NULL;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">void</span> CirQueue&lt;Datatype&gt;::ClearQueue()\n{\n    Head = Teal =QueueSize-<span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">//使队头与队尾都指在同一位置</span>\n    Length = <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">bool</span> CirQueue&lt;Datatype&gt;::QueueEmpty()\n{\n    <span class=\"hljs-keyword\">if</span> (Length == <span class=\"hljs-number\">0</span>)\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    }\n    <span class=\"hljs-keyword\">else</span>\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">bool</span> CirQueue&lt;Datatype&gt;::QueueFull()\n{\n    <span class=\"hljs-keyword\">if</span> (Length == QueueSize)\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    } \n    <span class=\"hljs-keyword\">else</span>\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">int</span> CirQueue&lt;Datatype&gt;::QueueLength()\n{\n    <span class=\"hljs-keyword\">return</span> Length;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">bool</span> CirQueue&lt;Datatype&gt;::EnQueue(Datatype x)\n{\n    <span class=\"hljs-keyword\">if</span> (QueueFull()) <span class=\"hljs-comment\">//入队时首先要判满；</span>\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    } \n    <span class=\"hljs-keyword\">else</span>\n    {\n        p_Queue[Teal] = x; <span class=\"hljs-comment\">//在队尾位置放元素；</span>\n        Teal = (Teal+<span class=\"hljs-number\">1</span>)%QueueSize; <span class=\"hljs-comment\">//放完元素后队尾指针自动往后滑一个长度，</span>\n        记得要与队列长度取余作为新队尾，防止上溢；\n        Length++;\n        <span class=\"hljs-comment\">//cout&lt;&lt; \"EnQueue Ok\" &lt;&lt;endl;</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    }\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">bool</span> CirQueue&lt;Datatype&gt;::DeQueue(Datatype &amp;x)\n{\n    <span class=\"hljs-comment\">//int temp = Head;</span>\n    <span class=\"hljs-keyword\">if</span> (QueueEmpty())\n    {\n        <span class=\"hljs-comment\">//cout&lt;&lt; \"下溢\" &lt;&lt;endl; </span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n    <span class=\"hljs-keyword\">else</span>\n    {\n        x = p_Queue[Head]; <span class=\"hljs-comment\">//将队头出队；</span>\n        Head = (Head+<span class=\"hljs-number\">1</span>)%QueueSize;\n        Length--;\n        <span class=\"hljs-comment\">//return p_Queue[temp];</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    }\n}\n\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\nDatatype CirQueue&lt;Datatype&gt;::GetQueue()\n{\n    <span class=\"hljs-keyword\">return</span> p_Queue[Head];\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">void</span> CirQueue&lt;Datatype&gt;::QueueTraverse()\n{\n    <span class=\"hljs-keyword\">if</span> (QueueEmpty())\n    {\n        <span class=\"hljs-comment\">//throw \"这是一个空队列\";</span>\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt; <span class=\"hljs-string\">\"这是一个空队列!\"</span> &lt;&lt;endl;\n        <span class=\"hljs-comment\">//return false;</span>\n    } \n    <span class=\"hljs-keyword\">else</span>\n    {\n    <span class=\"hljs-comment\">//从队头开始往后访问遍历；</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = Head;i&lt;Length+Head;i++)\n        {\n            <span class=\"hljs-built_in\">cout</span>&lt;&lt; p_Queue[i%QueueSize] &lt;&lt;endl;\n            <span class=\"hljs-comment\">//cout&lt;&lt;\"********************************\"&lt;&lt;endl;</span>\n        }\n    }\n}\n\n<span class=\"hljs-preprocessor\">#endif</span></code></pre>\n\n<p>2.一下是CirQueue.cpp调试文件的源代码：</p>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs cpp\"><span class=\"hljs-preprocessor\">#include &lt;iostream&gt;</span>\n<span class=\"hljs-comment\">//#include &lt;stdlib.h&gt;</span>\n<span class=\"hljs-preprocessor\">#include \"CirQueue.h\"</span>\n<span class=\"hljs-preprocessor\">#include \"CirQueue.cpp\"</span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-keyword\">int</span> main()\n{\n    CirQueue&lt;<span class=\"hljs-keyword\">int</span>&gt; MyQueue(<span class=\"hljs-number\">4</span>);\n\n    <span class=\"hljs-keyword\">bool</span> EnQueue_1_bool;\n    EnQueue_1_bool = MyQueue.EnQueue(<span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"EnQueue_1_bool: \"</span>&lt;&lt; EnQueue_1_bool &lt;&lt;endl;\n\n    <span class=\"hljs-keyword\">bool</span> EnQueue_2_bool;\n    EnQueue_2_bool = MyQueue.EnQueue(<span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"EnQueue_2_bool: \"</span>&lt;&lt; EnQueue_2_bool &lt;&lt;endl;\n\n    <span class=\"hljs-keyword\">int</span> MyQueue_head;\n    MyQueue_head = MyQueue.GetQueue();\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"MyQueue_head: \"</span>&lt;&lt;MyQueue_head &lt;&lt;endl;\n\n    <span class=\"hljs-keyword\">int</span> MyQueue_length;\n    MyQueue_length = MyQueue.QueueLength();\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"MyQueue_length: \"</span>&lt;&lt; MyQueue_length &lt;&lt;endl;\n\n    <span class=\"hljs-keyword\">int</span> x;\n    MyQueue.DeQueue(x);\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"DeQueue: x = \"</span>&lt;&lt; x &lt;&lt;endl;\n\n    <span class=\"hljs-keyword\">int</span> y;\n\n    MyQueue.DeQueue(y);\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"DeQueue: y = \"</span>&lt;&lt; y &lt;&lt;endl;\n\n    <span class=\"hljs-keyword\">bool</span> Empty_bool;\n    Empty_bool = MyQueue.QueueEmpty();\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt;<span class=\"hljs-string\">\"Empty_bool: \"</span>&lt;&lt; Empty_bool &lt;&lt;endl;\n\n    MyQueue.EnQueue(<span class=\"hljs-number\">10</span>);\n    MyQueue.EnQueue(<span class=\"hljs-number\">20</span>);\n    MyQueue.EnQueue(<span class=\"hljs-number\">30</span>);\n    MyQueue.EnQueue(<span class=\"hljs-number\">40</span>);\n    MyQueue.QueueTraverse();\n\n    system(<span class=\"hljs-string\">\"pause\"</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n\n<hr/>\n\n<ul>\n<li><p><strong><em>第三夜：数据结构之——栈篇</em></strong></p>\n\n<p><strong>栈</strong>：栈是限定仅在表头（栈顶）进行插入和删除操作的线性表”栈“者,存储货物或供旅客住宿的地方,可引申为仓库、中转站，所以引入到计算机领域里，就是指数据暂时存储的地方，所以才有进栈、出栈的说法。</p>\n\n<p>栈的特点：后进先出（LIFO）这个很容易理解的~~先进电梯的人后出来，后进电梯的人先出来。</p>\n\n<p>栈其实很简单，只要掌握好top指针的技巧就很容易理解了，top指针就相当于桶里的一只小船，水涨船高，水降船降；</p>\n\n<ol><li>栈 的实现，一下是Mystack.h 文件的源码：</li></ol></li>\n</ul>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs cpp\"><span class=\"hljs-preprocessor\">#ifndef MYSTACK_H</span>\n<span class=\"hljs-preprocessor\">#define MYSTACK_H</span>\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">class</span> Mystack\n{\n    <span class=\"hljs-keyword\">public</span>:\n        Mystack(Datatype size);\n        ~Mystack();\n        <span class=\"hljs-keyword\">bool</span> stackEmpty();\n        <span class=\"hljs-keyword\">bool</span> stackFull();\n        <span class=\"hljs-keyword\">bool</span> push(Datatype x); <span class=\"hljs-comment\">//入栈；</span>\n        <span class=\"hljs-keyword\">bool</span> pop(Datatype &amp;x); <span class=\"hljs-comment\">//出栈；</span>\n        <span class=\"hljs-keyword\">void</span> clearStack();\n        <span class=\"hljs-keyword\">int</span> stackLength();\n        <span class=\"hljs-keyword\">void</span> stackTraverse(<span class=\"hljs-keyword\">bool</span> isFromeButtom);\n    <span class=\"hljs-keyword\">private</span>:\n        Datatype *p_Buffer;<span class=\"hljs-comment\">//栈的入口</span>\n        <span class=\"hljs-keyword\">int</span> Size; <span class=\"hljs-comment\">//栈的大小</span>\n        <span class=\"hljs-keyword\">int</span> Top; <span class=\"hljs-comment\">//栈顶，在栈中极为重要；</span>\n};\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\nMystack&lt;Datatype&gt;::Mystack( Datatype size )\n{\n    Size = size;\n    Top = <span class=\"hljs-number\">0</span>;\n    p_Buffer = <span class=\"hljs-keyword\">new</span> Datatype[Size];<span class=\"hljs-comment\">//在堆区申请一个数组来实现栈</span>\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\nMystack&lt;Datatype&gt;::~Mystack()\n{\n    <span class=\"hljs-keyword\">delete</span> []p_Buffer; \n    p_Buffer = NULL;\n}\n\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">bool</span> Mystack&lt;Datatype&gt;::stackEmpty()\n{\n    <span class=\"hljs-keyword\">if</span> (Top == <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">//栈顶可以实时的反应出栈的情况</span>\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    } \n    <span class=\"hljs-keyword\">else</span>\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">bool</span> Mystack&lt;Datatype&gt;::stackFull()\n{\n    <span class=\"hljs-keyword\">if</span> (Top == Size)\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    } \n    <span class=\"hljs-keyword\">else</span>\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">bool</span> Mystack&lt;Datatype&gt;::push( Datatype x )\n{\n    <span class=\"hljs-keyword\">if</span> (!stackFull())\n    {\n        p_Buffer[Top] = x; <span class=\"hljs-comment\">//每入栈一个元素后top自动向上移动一个位置，以作为下一次入栈的栈顶指针；</span>\n        Top++;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    } \n    <span class=\"hljs-keyword\">else</span>\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">bool</span> Mystack&lt;Datatype&gt;::pop(Datatype &amp;x)\n{\n    <span class=\"hljs-keyword\">if</span> (stackEmpty())\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    } \n    <span class=\"hljs-keyword\">else</span>\n    {\n        Top--;\n        x = p_Buffer[Top];<span class=\"hljs-comment\">//将栈顶指针下滑一位，指向出栈元素</span>\n    }\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">void</span> Mystack&lt;Datatype&gt;::clearStack()\n{\n    Top = <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">int</span> Mystack&lt;Datatype&gt;::stackLength()\n{\n    <span class=\"hljs-keyword\">return</span> Top;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> Datatype&gt;\n<span class=\"hljs-keyword\">void</span> Mystack&lt;Datatype&gt;::stackTraverse(<span class=\"hljs-keyword\">bool</span> isFromeButtom)\n{\n    <span class=\"hljs-keyword\">if</span> (isFromeButtom)\n    {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;Top;i++)\n        {\n            <span class=\"hljs-built_in\">cout</span>&lt;&lt; p_Buffer[i] ;<span class=\"hljs-comment\">//&lt;&lt; ',';</span>\n        }\n    } \n    <span class=\"hljs-keyword\">else</span>\n    {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=Top-<span class=\"hljs-number\">1</span>;i&gt;=<span class=\"hljs-number\">0</span>;i--)\n        {\n            <span class=\"hljs-built_in\">cout</span>&lt;&lt; p_Buffer[i] ;<span class=\"hljs-comment\">//&lt;&lt; ',';</span>\n        }\n    }\n}\n\n<span class=\"hljs-preprocessor\">#endif</span>\n</code></pre>\n\n<ol>\n<li>测试刚写的栈，Queue.cpp 的源码如下：</li>\n</ol>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs cpp\"><span class=\"hljs-preprocessor\">#include &lt;iostream&gt;</span>\n<span class=\"hljs-preprocessor\">#include \"Mystack.h\"</span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n\n<span class=\"hljs-keyword\">int</span> main()\n{\n    Mystack&lt;<span class=\"hljs-keyword\">char</span>&gt; mystack(<span class=\"hljs-number\">5</span>);\n\n    mystack.push(<span class=\"hljs-string\">'H'</span>);\n    mystack.push(<span class=\"hljs-string\">'e'</span>);\n    mystack.push(<span class=\"hljs-string\">'l'</span>);\n    mystack.push(<span class=\"hljs-string\">'l'</span>);\n    mystack.push(<span class=\"hljs-string\">'o'</span>);\n\n    mystack.stackTraverse(<span class=\"hljs-keyword\">true</span>);\n\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt; endl;\n\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt; mystack.stackLength() &lt;&lt;endl;\n\n    <span class=\"hljs-keyword\">char</span> x = <span class=\"hljs-string\">'x'</span>;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt; mystack.pop(x) &lt;&lt;endl;\n\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt; mystack.stackLength() &lt;&lt;endl;\n\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt; mystack.stackEmpty() &lt;&lt;endl;\n\n    mystack.clearStack();\n\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt; mystack.stackEmpty() &lt;&lt;endl;\n\n    <span class=\"hljs-keyword\">char</span> y = <span class=\"hljs-string\">'t'</span>;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt; mystack.pop(x) &lt;&lt;endl;\n\n\n    system(<span class=\"hljs-string\">\"pause\"</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n\n<ol>\n<li>用栈实现十进制转二进制、八进制、十六进制；源码如下：</li>\n</ol>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs axapta\"><span class=\"hljs-preprocessor\">#include &lt;iostream&gt;</span>\n<span class=\"hljs-preprocessor\">#include \"Mystack.h\"</span>\n\nusing namespace std;\n\n<span class=\"hljs-preprocessor\">#define BINARY 2</span>\n<span class=\"hljs-preprocessor\">#define OCTONARY 8</span>\n<span class=\"hljs-preprocessor\">#define HEXADECIMAL 16</span>\n\n<span class=\"hljs-comment\">//用辗转相初法求模；</span>\n\n\n<span class=\"hljs-comment\">//template &lt;class Datatype&gt;</span>\n<span class=\"hljs-keyword\">void</span> to_binary(<span class=\"hljs-keyword\">int</span> n,<span class=\"hljs-keyword\">int</span> <span class=\"hljs-keyword\">mod</span>,Mystack&lt;<span class=\"hljs-keyword\">int</span>&gt; *p_b_stack)\n{\n    <span class=\"hljs-keyword\">while</span> (n != <span class=\"hljs-number\">0</span>)\n    {\n        <span class=\"hljs-keyword\">mod</span> = n % BINARY;\n        p_b_stack-&gt;push(<span class=\"hljs-keyword\">mod</span>);\n        n = n / BINARY;\n    }\n\n    p_b_stack-&gt;stackTraverse(<span class=\"hljs-keyword\">false</span>);\n    cout&lt;&lt;endl;\n}\n\n<span class=\"hljs-keyword\">void</span> to_octonary(<span class=\"hljs-keyword\">int</span> n,<span class=\"hljs-keyword\">int</span> <span class=\"hljs-keyword\">mod</span>,Mystack&lt;<span class=\"hljs-keyword\">int</span>&gt; *p_o_stack)\n{\n    <span class=\"hljs-keyword\">while</span> (n != <span class=\"hljs-number\">0</span>)\n    {\n        <span class=\"hljs-keyword\">mod</span> = n % OCTONARY;\n        p_o_stack-&gt;push(<span class=\"hljs-keyword\">mod</span>);\n        n = n / OCTONARY;\n    }\n\n    p_o_stack-&gt;stackTraverse(<span class=\"hljs-keyword\">false</span>);\n    cout&lt;&lt;endl;\n}\n\n<span class=\"hljs-keyword\">void</span> to_hexadecimal(<span class=\"hljs-keyword\">int</span> n,<span class=\"hljs-keyword\">int</span> <span class=\"hljs-keyword\">mod</span>,Mystack&lt;<span class=\"hljs-keyword\">int</span>&gt; *p_h_stack)\n{\n    <span class=\"hljs-keyword\">while</span> (n != <span class=\"hljs-number\">0</span>)\n    {\n        <span class=\"hljs-keyword\">mod</span> = n % HEXADECIMAL;\n        p_h_stack-&gt;push(<span class=\"hljs-keyword\">mod</span>);\n        n = n / HEXADECIMAL;\n    }\n    <span class=\"hljs-keyword\">char</span> <span class=\"hljs-keyword\">str</span>[] = <span class=\"hljs-string\">\"0123456789ABCDEF\"</span>;\n    <span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">while</span>(!p_h_stack-&gt;stackEmpty())\n    {\n        p_h_stack-&gt;pop(i);\n        cout&lt;&lt; <span class=\"hljs-keyword\">str</span>[i] ;\n    }\n\n    <span class=\"hljs-comment\">//p_e_stack-&gt;stackTraverse(false);</span>\n    cout&lt;&lt;endl;\n}\n\n<span class=\"hljs-keyword\">int</span> main()\n{\n    Mystack&lt;<span class=\"hljs-keyword\">int</span>&gt; *p_b_stack = <span class=\"hljs-keyword\">new</span> Mystack&lt;<span class=\"hljs-keyword\">int</span>&gt;(<span class=\"hljs-number\">20</span>);\n    Mystack&lt;<span class=\"hljs-keyword\">int</span>&gt; *p_o_stack = <span class=\"hljs-keyword\">new</span> Mystack&lt;<span class=\"hljs-keyword\">int</span>&gt;(<span class=\"hljs-number\">20</span>);\n    Mystack&lt;<span class=\"hljs-keyword\">int</span>&gt; *p_h_stack = <span class=\"hljs-keyword\">new</span> Mystack&lt;<span class=\"hljs-keyword\">int</span>&gt;(<span class=\"hljs-number\">20</span>);\n\n    <span class=\"hljs-keyword\">int</span> n = <span class=\"hljs-number\">1</span>;\n    cin&gt;&gt;n;\n    <span class=\"hljs-keyword\">int</span> <span class=\"hljs-keyword\">mod</span> = <span class=\"hljs-number\">0</span>;\n\n    to_binary(n,<span class=\"hljs-keyword\">mod</span>,p_b_stack);\n    to_octonary(n,<span class=\"hljs-keyword\">mod</span>,p_o_stack);\n    to_hexadecimal(n,<span class=\"hljs-keyword\">mod</span>,p_h_stack);\n\n    delete p_b_stack;\n    delete p_o_stack;\n    delete p_h_stack;\n    p_b_stack = NULL;\n    p_o_stack = NULL;\n    p_h_stack = NULL;\n\n    system(<span class=\"hljs-string\">\"pause\"</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}</code></pre>\n\n<hr/>\n\n<ul>\n<li><p><strong><em>第四夜：数据结构之——树篇</em></strong></p>\n\n<p><strong>树</strong>：树是由根结点和若干颗子树构成的。树是由一个集合以及在该集合上定义的一种关系构成的。集合中的元素称为树的结点，所定义的关系称为父子关系。父子关系在树的结点之间建立了一个层次结构。在这种层次结构中有一个结点具有特殊的地位，这个结点称为该树的根结点，或称为树根。</p>\n\n<p><strong>树的种类</strong>：</p>\n\n<p>无序树：树中任意节点的子结点之间没有顺序关系，这种树称为无序树,也称为自由树;</p>\n\n<p>有序树：树中任意节点的子结点之间有顺序关系，这种树 <br/>\n称为有序树；</p>\n\n<p>二叉树：每个节点最多含有两个子树的树称为二叉树；</p>\n\n<p>完全二叉树</p>\n\n<p>满二叉树</p>\n\n<p>霍夫曼树：带权路径最短的二叉树称为哈夫曼树或最优二 <br/>\n叉树；</p></li>\n</ul>\n\n<p>下面我重点来看二叉树：</p>\n\n<p><strong>二叉树</strong>：二叉树在图论中是这样定义的：二叉树是一个连 <br/>\n通的无环图，并且每一个顶点的度不大于3。有根二叉树还要满 <br/>\n足根结点的度不大于2。有了根结点之后，每个顶点定义了唯一 <br/>\n的父结点，和最多2个子结点。</p>\n\n<p>我主要总结了二叉树的数组实现和链表实现两种方式；</p>\n\n<pre><code>**注意**：学习二叉树我们的脑海中需要有父节点与左右孩子节点的思想\n</code></pre>\n\n<ul>\n<li><ol><li>下面是二叉树的数组实现</li></ol></li>\n</ul>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs cpp\">\n<span class=\"hljs-comment\">//以数组元素为节点；</span>\n\n<span class=\"hljs-preprocessor\">#ifndef TREE_H</span>\n<span class=\"hljs-preprocessor\">#define TREE_H</span>\n<span class=\"hljs-preprocessor\">#include &lt;iostream&gt;</span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">class</span> Tree\n{\n<span class=\"hljs-keyword\">public</span>:\n    Tree(<span class=\"hljs-keyword\">int</span> size,T *pRoot); <span class=\"hljs-comment\">//给定数的大小，以及根</span>\n    ~Tree();\n    T *SerchNode(<span class=\"hljs-keyword\">int</span> nodeIndex); <span class=\"hljs-comment\">//搜寻节点</span>\n    <span class=\"hljs-keyword\">bool</span> AddNode(<span class=\"hljs-keyword\">int</span> nodeIndex,<span class=\"hljs-keyword\">int</span> derection,T *node);<span class=\"hljs-comment\">//添加节点；</span>\n    <span class=\"hljs-keyword\">bool</span> DeleteNode(<span class=\"hljs-keyword\">int</span> nodexIndex,T *node); <span class=\"hljs-comment\">//删除节点</span>\n    <span class=\"hljs-keyword\">void</span> TreeTreaverse();\n<span class=\"hljs-keyword\">private</span>:\n    T *p_Tree;\n    <span class=\"hljs-keyword\">int</span> Size;\n};\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\nTree&lt;T&gt;::Tree( <span class=\"hljs-keyword\">int</span> size,T *pRoot )\n{\n    Size = size;\n    p_Tree = <span class=\"hljs-keyword\">new</span> T[Size]; <span class=\"hljs-comment\">//在堆区申请一个数组来实现二叉树</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;size;i++) <span class=\"hljs-comment\">//对每个节点初始化</span>\n    {\n        p_Tree[i] = NULL;\n    }\n    p_Tree[<span class=\"hljs-number\">0</span>] = *pRoot; <span class=\"hljs-comment\">//定义根节点</span>\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\nTree&lt;T&gt;::~Tree()\n{\n    <span class=\"hljs-keyword\">delete</span> []p_Tree;\n    p_Tree = NULL;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\nT * Tree&lt;T&gt;::SerchNode( <span class=\"hljs-keyword\">int</span> nodeIndex )\n{\n    <span class=\"hljs-keyword\">if</span> (nodeIndex&lt;<span class=\"hljs-number\">0</span> || nodeIndex&gt;Size)\n    {\n        <span class=\"hljs-keyword\">return</span> NULL;\n    }\n    <span class=\"hljs-keyword\">if</span> (NULL == p_Tree[nodeIndex])\n    {\n        <span class=\"hljs-keyword\">return</span> NULL;\n    }\n    <span class=\"hljs-keyword\">return</span> &amp;p_Tree[nodeIndex];\n}\n\n<span class=\"hljs-comment\">//添加为左节点index = nodeIndex*2 + 1;右节点: index = nodeIdex*2 + 2;</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">bool</span> Tree&lt;T&gt;::AddNode( <span class=\"hljs-keyword\">int</span> nodeIndex,<span class=\"hljs-keyword\">int</span> derection,T *node )\n{\n    <span class=\"hljs-keyword\">if</span> (nodeIndex&lt;<span class=\"hljs-number\">0</span> || nodeIndex&gt;Size)\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n    <span class=\"hljs-keyword\">if</span> (NULL == p_Tree[nodeIndex])\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n    <span class=\"hljs-keyword\">if</span> (derection == <span class=\"hljs-number\">0</span>)\n    {\n        <span class=\"hljs-keyword\">if</span> (nodeIndex*<span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>&gt;Size)\n        {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (NULL != p_Tree[nodeIndex*<span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>])\n        {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> ( nodeIndex*<span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span> &lt;= Size )\n        {\n            p_Tree[nodeIndex*<span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>] = *node;\n        }\n    }\n    <span class=\"hljs-keyword\">if</span> (derection == <span class=\"hljs-number\">1</span>)\n    {\n        <span class=\"hljs-keyword\">if</span> (nodeIndex*<span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>&gt;Size)\n        {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (NULL != p_Tree[nodeIndex*<span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>])\n        {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> ( nodeIndex*<span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span> &lt;= Size )\n        {\n            p_Tree[nodeIndex*<span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>] = *node;\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">bool</span> Tree&lt;T&gt;::DeleteNode( <span class=\"hljs-keyword\">int</span> nodeIndex,T *node )\n{\n    <span class=\"hljs-keyword\">if</span> (nodeIndex&lt;<span class=\"hljs-number\">0</span> || nodeIndex&gt;Size)\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n    <span class=\"hljs-keyword\">if</span> (NULL == p_Tree[nodeIndex])\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n    *node = p_Tree[nodeIndex];\n    p_Tree[nodeIndex] = NULL;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">void</span> Tree&lt;T&gt;::TreeTreaverse()\n{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> k=<span class=\"hljs-number\">0</span>;k&lt;Size;k++)\n    {\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt; p_Tree[k] &lt;&lt; <span class=\"hljs-string\">\" \"</span> &lt;&lt;endl;\n    }\n}\n\n\n<span class=\"hljs-preprocessor\">#endif</span></code></pre>\n\n<ul>\n<li><p>下面是二叉树的链表实现：</p>\n\n<ol><li>首先先完成一个节点类的书写，主要存储节点索引，数据，左、右孩子节点的指针，父节点的指针； <br/>\n下面是Node.h 文件的源码：因为二叉树是递归定义的，其结点 <br/>\n有左右子树之分，所以很多需要方法都需要用到递归函数，这 <br/>\n些方法我们写在了Node类里。</li></ol></li>\n</ul>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs lasso\"><span class=\"hljs-variable\">#ifndef</span> NODE_H\n<span class=\"hljs-variable\">#define</span> NODE_H\n<span class=\"hljs-variable\">#include</span> <span class=\"hljs-subst\">&lt;</span>iostream<span class=\"hljs-subst\">&gt;</span>\n\nusing namespace std;\n\ntemplate <span class=\"hljs-subst\">&lt;</span>class T<span class=\"hljs-subst\">&gt;</span>\nclass Node\n{\n<span class=\"hljs-keyword\">public</span>:\n    Node();\n    T <span class=\"hljs-built_in\">data</span>; <span class=\"hljs-comment\">//数据域;</span>\n    int index;\n    Node<span class=\"hljs-subst\">&lt;</span>T<span class=\"hljs-subst\">&gt;</span> <span class=\"hljs-subst\">*</span>pLchild; <span class=\"hljs-comment\">//左孩子节点指针；</span>\n    Node<span class=\"hljs-subst\">&lt;</span>T<span class=\"hljs-subst\">&gt;</span> <span class=\"hljs-subst\">*</span>pRchild; <span class=\"hljs-comment\">//右孩子节点指针；</span>\n    Node<span class=\"hljs-subst\">&lt;</span>T<span class=\"hljs-subst\">&gt;</span> <span class=\"hljs-subst\">*</span>pParent; <span class=\"hljs-comment\">//父节点;</span>\n    <span class=\"hljs-literal\">void</span> DeleteNode();\n    <span class=\"hljs-literal\">void</span> PreorderTraversal(); <span class=\"hljs-comment\">//前序遍历</span>\n    <span class=\"hljs-literal\">void</span> InorderTraversal(); <span class=\"hljs-comment\">//中序遍历</span>\n    <span class=\"hljs-literal\">void</span> PostorderTraversal(); <span class=\"hljs-comment\">//后序遍历</span>\n    Node<span class=\"hljs-subst\">&lt;</span>T<span class=\"hljs-subst\">&gt;</span> <span class=\"hljs-subst\">*</span>SearchNode(int nodeIndex); <span class=\"hljs-comment\">//寻找节点</span>\n\n};\n\ntemplate <span class=\"hljs-subst\">&lt;</span>class T<span class=\"hljs-subst\">&gt;</span>\nNode<span class=\"hljs-subst\">&lt;</span>T<span class=\"hljs-subst\">&gt;</span><span class=\"hljs-tag\">::Node</span>()\n{\n    index <span class=\"hljs-subst\">=</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-built_in\">data</span> <span class=\"hljs-subst\">=</span> <span class=\"hljs-built_in\">NULL</span>;\n    pLchild <span class=\"hljs-subst\">=</span> <span class=\"hljs-built_in\">NULL</span>;\n    pRchild <span class=\"hljs-subst\">=</span> <span class=\"hljs-built_in\">NULL</span>;\n    pParent <span class=\"hljs-subst\">=</span> <span class=\"hljs-built_in\">NULL</span>;\n}\n\ntemplate <span class=\"hljs-subst\">&lt;</span>class T<span class=\"hljs-subst\">&gt;</span>\nNode<span class=\"hljs-subst\">&lt;</span>T<span class=\"hljs-subst\">&gt;</span> <span class=\"hljs-subst\">*</span> Node<span class=\"hljs-subst\">&lt;</span>T<span class=\"hljs-subst\">&gt;</span><span class=\"hljs-tag\">::SearchNode</span>( int nodeIndex )\n{\n    Node<span class=\"hljs-subst\">&lt;</span>T<span class=\"hljs-subst\">&gt;</span> <span class=\"hljs-subst\">*</span>temp;\n    <span class=\"hljs-keyword\">if</span> ( this<span class=\"hljs-subst\">-&gt;</span>index <span class=\"hljs-subst\">==</span> nodeIndex ) <span class=\"hljs-comment\">//如果所给节点为当前节点，便返回当前节点；</span>\n    {\n        <span class=\"hljs-keyword\">return</span> this;\n    }\n    <span class=\"hljs-keyword\">if</span> (this<span class=\"hljs-subst\">-&gt;</span>pLchild <span class=\"hljs-subst\">!=</span> <span class=\"hljs-built_in\">NULL</span>) <span class=\"hljs-comment\">//首先判断左孩子存不存在</span>\n    {\n    <span class=\"hljs-comment\">//看看左孩子是否为所找；</span>\n        <span class=\"hljs-keyword\">if</span> (this<span class=\"hljs-subst\">-&gt;</span>pLchild<span class=\"hljs-subst\">-&gt;</span>index <span class=\"hljs-subst\">==</span> nodeIndex)\n        {\n            <span class=\"hljs-keyword\">return</span> this<span class=\"hljs-subst\">-&gt;</span>pLchild;\n        }\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-comment\">//否则就调用递归查找</span>\n        {\n            temp <span class=\"hljs-subst\">=</span> this<span class=\"hljs-subst\">-&gt;</span>pLchild<span class=\"hljs-subst\">-&gt;</span>SearchNode(nodeIndex);\n            <span class=\"hljs-keyword\">if</span> (temp <span class=\"hljs-subst\">!=</span> <span class=\"hljs-number\">0</span>)\n            {\n                <span class=\"hljs-keyword\">return</span> temp;\n            }\n        }\n    }\n    <span class=\"hljs-comment\">//再判断右孩子存不存在</span>\n    <span class=\"hljs-keyword\">if</span> (this<span class=\"hljs-subst\">-&gt;</span>pRchild <span class=\"hljs-subst\">!=</span> <span class=\"hljs-built_in\">NULL</span>)\n    {\n    <span class=\"hljs-comment\">//判断右孩子是否为所找</span>\n        <span class=\"hljs-keyword\">if</span> (this<span class=\"hljs-subst\">-&gt;</span>pRchild<span class=\"hljs-subst\">-&gt;</span>index <span class=\"hljs-subst\">==</span> nodeIndex)\n        {\n            <span class=\"hljs-keyword\">return</span> this<span class=\"hljs-subst\">-&gt;</span>pRchild;\n        }\n        <span class=\"hljs-comment\">//否则在调用递归查询</span>\n        <span class=\"hljs-keyword\">else</span>\n        {\n            temp <span class=\"hljs-subst\">=</span> this<span class=\"hljs-subst\">-&gt;</span>pRchild<span class=\"hljs-subst\">-&gt;</span>SearchNode(nodeIndex);\n            <span class=\"hljs-keyword\">if</span> (temp <span class=\"hljs-subst\">!=</span> <span class=\"hljs-number\">0</span>)\n            {\n                <span class=\"hljs-keyword\">return</span> temp;\n            }\n        }\n\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">NULL</span>;\n}\n\ntemplate <span class=\"hljs-subst\">&lt;</span>class T<span class=\"hljs-subst\">&gt;</span>\n<span class=\"hljs-literal\">void</span> Node<span class=\"hljs-subst\">&lt;</span>T<span class=\"hljs-subst\">&gt;</span><span class=\"hljs-tag\">::DeleteNode</span>()\n{\n    <span class=\"hljs-comment\">//判断左孩子是否为空，若不为空就调用递归删除</span>\n    <span class=\"hljs-keyword\">if</span> (this<span class=\"hljs-subst\">-&gt;</span>pLchild <span class=\"hljs-subst\">!=</span> <span class=\"hljs-built_in\">NULL</span>)\n    {\n        this<span class=\"hljs-subst\">-&gt;</span>pLchild<span class=\"hljs-subst\">-&gt;</span>DeleteNode();\n    }\n\n    <span class=\"hljs-comment\">//判断左孩子是否为空，若不为空就调用递归删除</span>\n    <span class=\"hljs-keyword\">if</span> (this<span class=\"hljs-subst\">-&gt;</span>pRchild <span class=\"hljs-subst\">!=</span> <span class=\"hljs-built_in\">NULL</span>)\n    {\n        this<span class=\"hljs-subst\">-&gt;</span>pRchild<span class=\"hljs-subst\">-&gt;</span>DeleteNode();\n    }\n    <span class=\"hljs-comment\">//判断该节点的父节点是否为空，因为空节点没有左右孩子</span>\n    <span class=\"hljs-keyword\">if</span> (this<span class=\"hljs-subst\">-&gt;</span>pParent <span class=\"hljs-subst\">!=</span> <span class=\"hljs-built_in\">NULL</span>)\n    {\n        <span class=\"hljs-comment\">//判断该节点是否为父节点的左孩子，并删除</span>\n        <span class=\"hljs-keyword\">if</span> (this<span class=\"hljs-subst\">-&gt;</span>pParent<span class=\"hljs-subst\">-&gt;</span>pLchild <span class=\"hljs-subst\">==</span> this)\n        {\n            this<span class=\"hljs-subst\">-&gt;</span>pParent<span class=\"hljs-subst\">-&gt;</span>pLchild <span class=\"hljs-subst\">=</span> <span class=\"hljs-built_in\">NULL</span>;\n        }\n        <span class=\"hljs-comment\">//判断该节点是否为父节点的右孩子，并删除</span>\n        <span class=\"hljs-keyword\">if</span> (this<span class=\"hljs-subst\">-&gt;</span>pParent<span class=\"hljs-subst\">-&gt;</span>pRchild <span class=\"hljs-subst\">==</span> this)\n        {\n            this<span class=\"hljs-subst\">-&gt;</span>pParent<span class=\"hljs-subst\">-&gt;</span>pRchild <span class=\"hljs-subst\">=</span> <span class=\"hljs-built_in\">NULL</span>;\n        }\n    }\n    delete this; <span class=\"hljs-comment\">//所有的子节点都删除完了，再删除自己</span>\n}\n\ntemplate <span class=\"hljs-subst\">&lt;</span>class T<span class=\"hljs-subst\">&gt;</span>\n<span class=\"hljs-literal\">void</span> Node<span class=\"hljs-subst\">&lt;</span>T<span class=\"hljs-subst\">&gt;</span><span class=\"hljs-tag\">::PreorderTraversal</span>()\n{\n<span class=\"hljs-comment\">//前序遍历，根-左-右</span>\n    cout<span class=\"hljs-subst\">&lt;&lt;</span> this<span class=\"hljs-subst\">-&gt;</span>index <span class=\"hljs-subst\">&lt;&lt;</span> <span class=\"hljs-string\">\"---&gt;\"</span> <span class=\"hljs-subst\">&lt;&lt;</span> this<span class=\"hljs-subst\">-&gt;</span><span class=\"hljs-built_in\">data</span> <span class=\"hljs-subst\">&lt;&lt;</span>endl;\n    <span class=\"hljs-comment\">//若左孩子存在，调用递归进行前序遍历</span>\n    <span class=\"hljs-keyword\">if</span> (this<span class=\"hljs-subst\">-&gt;</span>pLchild <span class=\"hljs-subst\">!=</span> <span class=\"hljs-built_in\">NULL</span>)\n    {\n        this<span class=\"hljs-subst\">-&gt;</span>pLchild<span class=\"hljs-subst\">-&gt;</span>PreorderTraversal();\n    }\n    <span class=\"hljs-comment\">//若右孩子存在，调用递归进行前序遍历</span>\n    <span class=\"hljs-keyword\">if</span> (this<span class=\"hljs-subst\">-&gt;</span>pRchild <span class=\"hljs-subst\">!=</span> <span class=\"hljs-built_in\">NULL</span>)\n    {\n        this<span class=\"hljs-subst\">-&gt;</span>pRchild<span class=\"hljs-subst\">-&gt;</span>PreorderTraversal();\n    }\n}\n\ntemplate <span class=\"hljs-subst\">&lt;</span>class T<span class=\"hljs-subst\">&gt;</span>\n<span class=\"hljs-literal\">void</span> Node<span class=\"hljs-subst\">&lt;</span>T<span class=\"hljs-subst\">&gt;</span><span class=\"hljs-tag\">::InorderTraversal</span>()\n{\n<span class=\"hljs-comment\">//中序遍历，左-根-右</span>\n    <span class=\"hljs-keyword\">if</span> (this<span class=\"hljs-subst\">-&gt;</span>pLchild <span class=\"hljs-subst\">!=</span> <span class=\"hljs-built_in\">NULL</span>)\n    {\n        this<span class=\"hljs-subst\">-&gt;</span>pLchild<span class=\"hljs-subst\">-&gt;</span>InorderTraversal();\n    }\n    cout<span class=\"hljs-subst\">&lt;&lt;</span> this<span class=\"hljs-subst\">-&gt;</span>index <span class=\"hljs-subst\">&lt;&lt;</span> <span class=\"hljs-string\">\"---&gt;\"</span> <span class=\"hljs-subst\">&lt;&lt;</span> this<span class=\"hljs-subst\">-&gt;</span><span class=\"hljs-built_in\">data</span> <span class=\"hljs-subst\">&lt;&lt;</span>endl;\n    <span class=\"hljs-keyword\">if</span> (this<span class=\"hljs-subst\">-&gt;</span>pRchild <span class=\"hljs-subst\">!=</span> <span class=\"hljs-built_in\">NULL</span>)\n    {\n        this<span class=\"hljs-subst\">-&gt;</span>pRchild<span class=\"hljs-subst\">-&gt;</span>InorderTraversal();\n    }\n}\n\ntemplate <span class=\"hljs-subst\">&lt;</span>class T<span class=\"hljs-subst\">&gt;</span>\n<span class=\"hljs-literal\">void</span> Node<span class=\"hljs-subst\">&lt;</span>T<span class=\"hljs-subst\">&gt;</span><span class=\"hljs-tag\">::PostorderTraversal</span>()\n{\n<span class=\"hljs-comment\">//后序遍历，左-右-根</span>\n    <span class=\"hljs-keyword\">if</span> (this<span class=\"hljs-subst\">-&gt;</span>pLchild <span class=\"hljs-subst\">!=</span> <span class=\"hljs-built_in\">NULL</span>)\n    {\n        this<span class=\"hljs-subst\">-&gt;</span>pLchild<span class=\"hljs-subst\">-&gt;</span>PostorderTraversal();\n    }\n    <span class=\"hljs-keyword\">if</span> (this<span class=\"hljs-subst\">-&gt;</span>pRchild <span class=\"hljs-subst\">!=</span> <span class=\"hljs-built_in\">NULL</span>)\n    {\n        this<span class=\"hljs-subst\">-&gt;</span>pRchild<span class=\"hljs-subst\">-&gt;</span>PostorderTraversal();\n    }\n    cout<span class=\"hljs-subst\">&lt;&lt;</span> this<span class=\"hljs-subst\">-&gt;</span>index <span class=\"hljs-subst\">&lt;&lt;</span> <span class=\"hljs-string\">\"---&gt;\"</span> <span class=\"hljs-subst\">&lt;&lt;</span> this<span class=\"hljs-subst\">-&gt;</span><span class=\"hljs-built_in\">data</span> <span class=\"hljs-subst\">&lt;&lt;</span>endl;\n}\n\n\n\n<span class=\"hljs-variable\">#endif</span></code></pre>\n\n<p>再将每个节点按照二叉树的关系联合起来，所以用一个LinkListTree类进行整合；LinkListTree.h 的源码如下：</p>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs cpp\"><span class=\"hljs-preprocessor\">#ifndef TREE_H</span>\n<span class=\"hljs-preprocessor\">#define TREE_H</span>\n<span class=\"hljs-preprocessor\">#include \"Node.h\"</span>\n<span class=\"hljs-preprocessor\">#include &lt;iostream&gt;</span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">class</span> LinkListTree\n{\n<span class=\"hljs-keyword\">public</span>:\n    LinkListTree();\n    ~LinkListTree();\n    Node&lt;T&gt; *SearchNode(<span class=\"hljs-keyword\">int</span> nodeIndex);\n    <span class=\"hljs-keyword\">bool</span> AddNode(<span class=\"hljs-keyword\">int</span> nodeIndex,<span class=\"hljs-keyword\">int</span> derection,Node&lt;T&gt; *pNode);\n    <span class=\"hljs-keyword\">bool</span> DeleteNode(<span class=\"hljs-keyword\">int</span> nodexIndex,Node&lt;T&gt; *pNode);\n    <span class=\"hljs-keyword\">void</span> PreorderTraversal();\n    <span class=\"hljs-keyword\">void</span> InorderTraversal();\n    <span class=\"hljs-keyword\">void</span> PostorderTraversal();\n\n<span class=\"hljs-keyword\">private</span>:\n    Node&lt;T&gt; *pRoot;\n};\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\nLinkListTree&lt;T&gt;::LinkListTree()\n{\n    pRoot = <span class=\"hljs-keyword\">new</span> Node&lt;T&gt;;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\nLinkListTree&lt;T&gt;::~LinkListTree()\n{\n    pRoot-&gt;DeleteNode();\n    <span class=\"hljs-comment\">//delete pRoot;</span>\n    <span class=\"hljs-comment\">//pRoot = NULL;</span>\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\nNode&lt;T&gt; * LinkListTree&lt;T&gt;::SearchNode( <span class=\"hljs-keyword\">int</span> nodeIndex )\n{\n    <span class=\"hljs-keyword\">return</span> pRoot-&gt;SearchNode(nodeIndex);\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">bool</span> LinkListTree&lt;T&gt;::AddNode( <span class=\"hljs-keyword\">int</span> nodeIndex,<span class=\"hljs-keyword\">int</span> derection,Node&lt;T&gt; *pNode )\n{\n    Node&lt;T&gt; *temp = SearchNode(nodeIndex);\n    <span class=\"hljs-keyword\">if</span> (temp == NULL)\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n    Node&lt;T&gt; *newNode = <span class=\"hljs-keyword\">new</span> Node&lt;T&gt;;\n    <span class=\"hljs-keyword\">if</span> (newNode == NULL)\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n    newNode-&gt;index = pNode-&gt;index;\n    newNode-&gt;data = pNode-&gt;data;\n    newNode-&gt;pParent = temp;\n    <span class=\"hljs-keyword\">if</span> (derection == <span class=\"hljs-number\">0</span>)\n    {\n        temp-&gt;pLchild = newNode;\n    }\n    <span class=\"hljs-keyword\">if</span> (derection == <span class=\"hljs-number\">1</span>)\n    {\n        temp-&gt;pRchild = newNode;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">bool</span> LinkListTree&lt;T&gt;::DeleteNode( <span class=\"hljs-keyword\">int</span> nodeIndex,Node&lt;T&gt; *pNode )\n{\n    Node&lt;T&gt; *temp = SearchNode(nodeIndex);\n    <span class=\"hljs-keyword\">if</span> (temp == NULL)\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n    <span class=\"hljs-keyword\">if</span> (pNode != NULL)\n    {\n        pNode-&gt;data = temp-&gt;data;\n    }\n    temp-&gt;DeleteNode();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">void</span> LinkListTree&lt;T&gt;::PreorderTraversal()\n{\n    pRoot-&gt;PreorderTraversal();\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">void</span> LinkListTree&lt;T&gt;::InorderTraversal()\n{\n    pRoot-&gt;InorderTraversal();\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">void</span> LinkListTree&lt;T&gt;::PostorderTraversal()\n{\n    pRoot-&gt;PostorderTraversal();\n}\n\n\n\n<span class=\"hljs-preprocessor\">#endif</span></code></pre>\n\n<hr/>\n\n<ul>\n<li><p><strong><em>第五夜：数据结构之——图篇</em></strong></p>\n\n<p><strong>图</strong>：数据元素间的关系是任意的。其他数据结构(如树、线性表等)都有明确的条件限制，而图形结构中任意两个数据元素间均可相关联。常用来研究生产流程、施工计划、各种网络建设等问题。</p>\n\n<p>1 理解图的两大存储结构 <br/>\n1-1 邻接矩阵 <br/>\n1-2 邻接表 <br/>\n注意：邻接表中，指针数组里的每一个指针都是一个单链表的头指针 <br/>\n注意：单链表里每个节点里存储的是图中每条边的信息。</p>\n\n<p>2 理解图的遍历算法 <br/>\n2-1 深度优先遍历 <br/>\n2-2 宽度优先遍历 <br/>\n注意：又叫广度优先算法，需要一个队列</p>\n\n<p>3 图的最小代价生成树算法  <br/>\n3-1 普里姆算法        。 <br/>\n3-2 克鲁斯卡尔算法 <br/>\n注意：克鲁斯卡尔的时间复杂度</p></li>\n</ul>\n\n<p>下面我将总结由顶点数组(存节点)与邻接矩阵(存弧或边的相关 <br/>\n信息)构成的图;</p>\n\n<ol>\n<li>首先写出构成图的节点Node类，Node.h 的源码如下：</li>\n</ol>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs cpp\"><span class=\"hljs-preprocessor\">#ifndef NODE_H</span>\n<span class=\"hljs-preprocessor\">#define NODE_H</span>\n\n<span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">class</span> Node\n{\n<span class=\"hljs-keyword\">public</span>:\n    Node(T data = <span class=\"hljs-number\">0</span>);\n    T cData; <span class=\"hljs-comment\">//存数据</span>\n    <span class=\"hljs-keyword\">bool</span> bIsVisited; <span class=\"hljs-comment\">//节点的访问属性;</span>\n};\n\n<span class=\"hljs-keyword\">template</span>&lt;<span class=\"hljs-keyword\">class</span> T&gt;\nNode&lt;T&gt;::Node( T data )\n{\n    cData = data;\n    bIsVisited = <span class=\"hljs-keyword\">false</span>;\n}\n\n<span class=\"hljs-preprocessor\">#endif</span></code></pre>\n\n<ol>\n<li>由Node 节点构成边，所以写一个edge类，edge.h 的源码如下：</li>\n</ol>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs vala\"><span class=\"hljs-preprocessor\">#ifndef EDGE_H</span>\n<span class=\"hljs-preprocessor\">#define EDGE_H</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Edge</span>\n{</span>\n<span class=\"hljs-keyword\">public</span>:\n    Edge(<span class=\"hljs-keyword\">int</span> nodeIndexA = <span class=\"hljs-number\">0</span>,<span class=\"hljs-keyword\">int</span> nodeIndexB = <span class=\"hljs-number\">0</span>,<span class=\"hljs-keyword\">int</span> weightValue = <span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-keyword\">int</span> NodeIndexA; <span class=\"hljs-comment\">//节点A</span>\n    <span class=\"hljs-keyword\">int</span> NodeIndexB; <span class=\"hljs-comment\">//节点B</span>\n    <span class=\"hljs-keyword\">int</span> Weightvalue; <span class=\"hljs-comment\">//边的权值</span>\n    <span class=\"hljs-keyword\">bool</span> bSelected; <span class=\"hljs-comment\">//边的访问属性</span>\n};\n\nEdge::Edge( <span class=\"hljs-keyword\">int</span> nodeIndexA <span class=\"hljs-comment\">/*= 0*/</span>,<span class=\"hljs-keyword\">int</span> nodeIndexB <span class=\"hljs-comment\">/*= 0*/</span>,<span class=\"hljs-keyword\">int</span> weightValue <span class=\"hljs-comment\">/*= 0*/</span> )\n{\n    NodeIndexA = nodeIndexA;\n    NodeIndexB = nodeIndexB;\n    Weightvalue = weightValue;\n    bSelected = <span class=\"hljs-literal\">false</span>;\n}\n\n\n<span class=\"hljs-preprocessor\">#endif</span>\n</code></pre>\n\n<ol>\n<li>由边构成图形，所以写一个CMap类，用于整合edge形成图，cMap.h 的源码如下：</li>\n</ol>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs cpp\"><span class=\"hljs-preprocessor\">#ifndef CMAP_H</span>\n<span class=\"hljs-preprocessor\">#define CMAP_H</span>\n<span class=\"hljs-comment\">/*\n   Map 由顶点数组(存节点) 与 邻接矩阵(存弧或边的相关信息)构成;\n*/</span>\n<span class=\"hljs-preprocessor\">#include \"Node.h\"</span>\n<span class=\"hljs-preprocessor\">#include \"Edge.h\"</span>\n<span class=\"hljs-preprocessor\">#include &lt;vector&gt;</span>\n<span class=\"hljs-preprocessor\">#include &lt;iostream&gt;</span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">class</span> CMap\n{\n<span class=\"hljs-keyword\">public</span>:\n    CMap(<span class=\"hljs-keyword\">int</span> capacity);\n    ~CMap();\n    <span class=\"hljs-keyword\">bool</span> addNode(Node&lt;T&gt; *pNode);\n    <span class=\"hljs-keyword\">void</span> resetNode();\n    <span class=\"hljs-keyword\">bool</span> setValueToMatrixForDirectedGraph(<span class=\"hljs-keyword\">int</span> row,<span class=\"hljs-keyword\">int</span> col,<span class=\"hljs-keyword\">int</span> val = <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">bool</span> setValueToMatrixForUndirectedGraph(<span class=\"hljs-keyword\">int</span> row,<span class=\"hljs-keyword\">int</span> col,<span class=\"hljs-keyword\">int</span> val = <span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-keyword\">void</span> printMatrix();\n\n    <span class=\"hljs-keyword\">void</span> depthFirstTraverse(<span class=\"hljs-keyword\">int</span> nodeIndex); <span class=\"hljs-comment\">//深度优先遍历;</span>\n    <span class=\"hljs-keyword\">void</span> breadthFirstTraverse(<span class=\"hljs-keyword\">int</span> nodeIndex); <span class=\"hljs-comment\">//广度优先遍历;</span>\n\n    <span class=\"hljs-keyword\">void</span> primTree(<span class=\"hljs-keyword\">int</span> nodeIndex); <span class=\"hljs-comment\">//普利姆生成树算法;</span>\n\n<span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-keyword\">bool</span> getValueFromeMatrix(<span class=\"hljs-keyword\">int</span> row,<span class=\"hljs-keyword\">int</span> col,<span class=\"hljs-keyword\">int</span> &amp;val); <span class=\"hljs-comment\">//从函数中获取权值;</span>\n    <span class=\"hljs-keyword\">void</span> breadthFirstTraverseImpl(<span class=\"hljs-stl_container\"><span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;</span> preVec); <span class=\"hljs-comment\">//广度优先遍历实现函数;</span>\n\n    <span class=\"hljs-keyword\">int</span> getMinEdge(<span class=\"hljs-stl_container\"><span class=\"hljs-built_in\">vector</span>&lt;Edge&gt;</span> edgeVec);\n\n<span class=\"hljs-keyword\">private</span>:\n    <span class=\"hljs-keyword\">int</span> Capacity;\n    <span class=\"hljs-keyword\">int</span> NodeCount;\n    Node&lt;T&gt; *NodeArray;  <span class=\"hljs-comment\">//存放节点（顶点）的数组;</span>\n    <span class=\"hljs-keyword\">int</span> *pMatrix;    <span class=\"hljs-comment\">//存放弧关系信息的邻接矩阵;</span>\n\n    Edge *pEdge;\n};\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\nCMap&lt;T&gt;::CMap( <span class=\"hljs-keyword\">int</span> capacity )\n{\n    Capacity = capacity;\n    NodeCount = <span class=\"hljs-number\">0</span>;\n    NodeArray = <span class=\"hljs-keyword\">new</span> Node&lt;T&gt;[Capacity];\n    pMatrix = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[Capacity*Capacity];\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;Capacity*Capacity;i++)\n    {\n        pMatrix[i] = NULL;\n    }\n\n    pEdge = <span class=\"hljs-keyword\">new</span> Edge[Capacity-<span class=\"hljs-number\">1</span>];    <span class=\"hljs-comment\">//用于存放最小生成树中的所有边;</span>\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\nCMap&lt;T&gt;::~CMap()\n{\n    <span class=\"hljs-keyword\">delete</span> []NodeArray;\n    NodeArray = NULL;\n    <span class=\"hljs-keyword\">delete</span> []pMatrix;\n    pMatrix = NULL;\n\n    <span class=\"hljs-keyword\">delete</span> []Edge;\n    pEdge = NULL;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">bool</span> CMap&lt;T&gt;::addNode( Node&lt;T&gt; *pNode )\n{\n    <span class=\"hljs-keyword\">if</span> (pNode == NULL)\n    {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n    }\n    NodeArray[NodeCount].cData = pNode-&gt;cData;\n    NodeCount++;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">void</span> CMap&lt;T&gt;::resetNode()\n{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;NodeCount;i++)\n    {\n        NodeArray[i].bIsVisited = <span class=\"hljs-keyword\">false</span>;\n    }\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">bool</span> CMap&lt;T&gt;::setValueToMatrixForDirectedGraph( <span class=\"hljs-keyword\">int</span> row,<span class=\"hljs-keyword\">int</span> col,<span class=\"hljs-keyword\">int</span> val <span class=\"hljs-comment\">/*= 1*/</span> )\n{\n    <span class=\"hljs-keyword\">if</span> (row&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; row&lt;Capacity &amp;&amp; col&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; col&lt;Capacity)\n    {\n        pMatrix[row*Capacity + col] = val;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">bool</span> CMap&lt;T&gt;::setValueToMatrixForUndirectedGraph( <span class=\"hljs-keyword\">int</span> row,<span class=\"hljs-keyword\">int</span> col,<span class=\"hljs-keyword\">int</span> val <span class=\"hljs-comment\">/*= 1*/</span> )\n{\n    <span class=\"hljs-keyword\">if</span> (row&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; row&lt;Capacity &amp;&amp; col&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; col&lt;Capacity)\n    {\n        pMatrix[row*Capacity + col] = val;\n        pMatrix[col*Capacity + row] = val;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">bool</span> CMap&lt;T&gt;::getValueFromeMatrix( <span class=\"hljs-keyword\">int</span> row,<span class=\"hljs-keyword\">int</span> col,<span class=\"hljs-keyword\">int</span> &amp;val )\n{\n    <span class=\"hljs-keyword\">if</span> (row&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; row&lt;Capacity &amp;&amp; col&gt;=<span class=\"hljs-number\">0</span> &amp;&amp; col&lt;Capacity)\n    {\n        val = pMatrix[row*Capacity + col];\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">true</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">false</span>;\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">void</span> CMap&lt;T&gt;::printMatrix()\n{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;Capacity;i++)\n    {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;Capacity;j++)\n        {\n            <span class=\"hljs-built_in\">cout</span>&lt;&lt; pMatrix[i*Capacity + j] &lt;&lt;<span class=\"hljs-string\">' '</span>;\n        }\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt;endl;\n    }\n\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">void</span> CMap&lt;T&gt;::depthFirstTraverse( <span class=\"hljs-keyword\">int</span> nodeIndex )\n{\n    <span class=\"hljs-keyword\">int</span> val = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt; NodeArray[nodeIndex].cData &lt;&lt;<span class=\"hljs-string\">' '</span>;\n    NodeArray[nodeIndex].bIsVisited = <span class=\"hljs-keyword\">true</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;Capacity;i++)\n    {\n        getValueFromeMatrix(nodeIndex,i,val);\n        <span class=\"hljs-keyword\">if</span> (val == <span class=\"hljs-number\">1</span>)\n        {\n            <span class=\"hljs-keyword\">if</span> (NodeArray[i].bIsVisited)\n            {\n                <span class=\"hljs-keyword\">continue</span>;\n            }\n            <span class=\"hljs-keyword\">else</span>\n            {\n                depthFirstTraverse(i);\n            }\n        }\n        <span class=\"hljs-keyword\">else</span>\n        {\n            <span class=\"hljs-keyword\">continue</span>;\n        }\n    }\n\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">void</span> CMap&lt;T&gt;::breadthFirstTraverse( <span class=\"hljs-keyword\">int</span> nodeIndex )\n{\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt; NodeArray[nodeIndex].cData &lt;&lt;<span class=\"hljs-string\">' '</span>;\n    NodeArray[nodeIndex].bIsVisited = <span class=\"hljs-keyword\">true</span>;\n\n    <span class=\"hljs-stl_container\"><span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;</span> curVec;\n    curVec.push_back(nodeIndex);\n    breadthFirstTraverseImpl( curVec );\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">void</span> CMap&lt;T&gt;::breadthFirstTraverseImpl( <span class=\"hljs-stl_container\"><span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;</span> preVec )\n{\n    <span class=\"hljs-keyword\">int</span> value = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-stl_container\"><span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;</span> curVec;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j=<span class=\"hljs-number\">0</span>;j&lt;(<span class=\"hljs-keyword\">int</span>)preVec.size();j++)\n    {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;Capacity;i++)\n        {\n            getValueFromeMatrix(preVec[j],i,value);\n            <span class=\"hljs-keyword\">if</span> (value != <span class=\"hljs-number\">0</span>)\n            {\n                <span class=\"hljs-keyword\">if</span> (NodeArray[i].bIsVisited)\n                {\n                    <span class=\"hljs-keyword\">continue</span>;\n                } \n                <span class=\"hljs-keyword\">else</span>\n                {\n                    <span class=\"hljs-built_in\">cout</span>&lt;&lt;NodeArray[i].cData&lt;&lt;<span class=\"hljs-string\">' '</span>;\n                    NodeArray[i].bIsVisited = <span class=\"hljs-keyword\">true</span>;\n\n                    curVec.push_back(i);\n                }\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">if</span> (curVec.size() != <span class=\"hljs-number\">0</span>)\n    {\n        breadthFirstTraverseImpl(curVec);\n    }\n    <span class=\"hljs-keyword\">else</span>\n    {\n        <span class=\"hljs-keyword\">return</span>;\n    }\n}\n\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">int</span> CMap&lt;T&gt;::getMinEdge( <span class=\"hljs-stl_container\"><span class=\"hljs-built_in\">vector</span>&lt;Edge&gt;</span> edgeVec )\n{\n    <span class=\"hljs-keyword\">int</span> minWeight = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">int</span> edgeIndex = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-keyword\">for</span> (;i&lt;(<span class=\"hljs-keyword\">int</span>)edgeVec.size();i++)\n    {\n        <span class=\"hljs-keyword\">if</span> (!edgeVec[i].bSelected)\n        {\n            minWeight = edgeVec[i].Weightvalue;\n            edgeIndex = i;\n            <span class=\"hljs-comment\">//cout&lt;&lt;\"aaaa\"&lt;&lt;edgeIndex&lt;&lt;endl;</span>\n            <span class=\"hljs-keyword\">break</span>;\n        }\n    }\n    <span class=\"hljs-keyword\">if</span> (edgeIndex = <span class=\"hljs-number\">0</span>)\n    {\n        <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n    }\n    <span class=\"hljs-keyword\">for</span> (;i&lt;(<span class=\"hljs-keyword\">int</span>)edgeVec.size();i++)\n    {\n        <span class=\"hljs-keyword\">if</span> (!edgeVec[i].bSelected)\n        {\n            <span class=\"hljs-keyword\">if</span> (minWeight&gt;edgeVec[i].Weightvalue)\n            {\n                minWeight = edgeVec[i].Weightvalue;\n                edgeIndex = i;\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> edgeIndex;\n}\n\n<span class=\"hljs-comment\">//普利姆生成树算法;</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">class</span> T&gt;\n<span class=\"hljs-keyword\">void</span> CMap&lt;T&gt;::primTree( <span class=\"hljs-keyword\">int</span> nodeIndex )\n{\n    <span class=\"hljs-keyword\">int</span> value = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">//存放边的权值;</span>\n    <span class=\"hljs-keyword\">int</span> edgeCount = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-stl_container\"><span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-keyword\">int</span>&gt;</span> nodeVec; <span class=\"hljs-comment\">//存放点的(索引)集合;</span>\n    <span class=\"hljs-stl_container\"><span class=\"hljs-built_in\">vector</span>&lt;Edge&gt;</span> edgeVec; <span class=\"hljs-comment\">//存放边的集合;</span>\n    nodeVec.push_back(nodeIndex);\n\n    <span class=\"hljs-built_in\">cout</span>&lt;&lt; NodeArray[nodeIndex].cData &lt;&lt;endl;\n\n    <span class=\"hljs-keyword\">while</span>(edgeCount &lt; Capacity-<span class=\"hljs-number\">1</span>)\n    {\n        <span class=\"hljs-keyword\">int</span> temp = nodeVec.back();\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i=<span class=\"hljs-number\">0</span>;i&lt;Capacity;i++)\n        {\n            getValueFromeMatrix(temp,i,value);\n            <span class=\"hljs-comment\">//cout&lt;&lt;\"value:\"&lt;&lt;value&lt;&lt;endl;</span>\n            <span class=\"hljs-keyword\">if</span> (value != <span class=\"hljs-number\">0</span>)\n            {\n                <span class=\"hljs-comment\">//cout&lt;&lt;\"test\"&lt;&lt;endl;</span>\n                <span class=\"hljs-keyword\">if</span> (NodeArray[i].bIsVisited)\n                {\n                    <span class=\"hljs-keyword\">continue</span>;\n                }\n                <span class=\"hljs-keyword\">else</span>\n                {\n                    Edge edge(temp,i,value);<span class=\"hljs-comment\">//生成一个边对象;</span>\n                    edgeVec.push_back(edge);\n                }\n            }\n        }\n        <span class=\"hljs-comment\">//上一个for循环后获得了所有顶点的有关边，存到了edge数组里;</span>\n        <span class=\"hljs-comment\">//接下来从可选边集合中找出权值最小的边，添加到最小边数组中;</span>\n        <span class=\"hljs-keyword\">int</span> edgeIndex = getMinEdge(edgeVec);\n        <span class=\"hljs-comment\">//cout&lt;&lt;\"edgeIndex:\"&lt;&lt;edgeIndex&lt;&lt;endl;</span>\n        edgeVec[edgeIndex].bSelected = <span class=\"hljs-keyword\">true</span>;\n\n        pEdge[edgeCount] = edgeVec[edgeIndex];\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt;edgeVec[edgeIndex].NodeIndexA&lt;&lt;<span class=\"hljs-string\">\"---\"</span>&lt;&lt;edgeVec[edgeIndex].Weightvalue&lt;&lt;<span class=\"hljs-string\">\"---\"</span>;\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt;edgeVec[edgeIndex].NodeIndexB&lt;&lt;endl;\n        edgeCount++;\n\n        <span class=\"hljs-keyword\">int</span> nextNodeIndex = edgeVec[edgeIndex].NodeIndexB;<span class=\"hljs-comment\">//获得与该边相连接的下一个节点索引;</span>\n\n        nodeVec.push_back(nextNodeIndex);<span class=\"hljs-comment\">//将该索引添加到存放生成树的节点的数组中，以便下次遍历;</span>\n        NodeArray[nextNodeIndex].bIsVisited = <span class=\"hljs-keyword\">true</span>;\n        <span class=\"hljs-built_in\">cout</span>&lt;&lt;NodeArray[nextNodeIndex].cData&lt;&lt;endl;\n    }\n\n}\n\n\n<span class=\"hljs-preprocessor\">#endif</span></code></pre>\n\n\n\n<h3 id=\"写在后面\">写在后面</h3>\n\n<p>以上便是一个小白十天学习数据结构的基本所获，在这十天中 <br/>\n有曾撞了无数次墙，debug了无数次，有时调Bug调到绝望，也 <br/>\n曾想过放弃；当然整个过程也充满了惊喜，一边是对知识和技 <br/>\n巧的惊，一边是对获得之后的喜，可谓是收获了满满的成就感 <br/>\n，最终还是坚持到了图篇！</p>\n\n<p>另外，特别值得一提的是，我第一次写了一篇真正属于自己的 <br/>\n学习总结，还一不小心就写了这么长！在这里小小的鼓励一下 <br/>\n自己。。。。。。当然我更希望各位朋友多多指教，有不对的 <br/>\n地方还望多多包容与纠正~~感激不尽！</p>\n\n<p>最后，我还想说的是，感谢慕课网以及里面授教的james_yuan老师，james老师教的的真的是一级棒，不经思路清晰，更重要的是细微入至，可谓是手把手教学啊！文中的绝大部分代码都是我跟着james老师学习之后的成果；再次给大家推荐james老师在慕课网的数据结构课程，真乃良心课程~~~</p>\n\n<p>希望本文章能给和我一样不甘平凡的人带来一丝丝的帮助，那将是我的万分荣幸！</p>\n\n<p>附：慕课网James老师课程：[1]<a href=\"https://www.imooc.com/course/list?c=cplusplus\" target=\"_blank\">https://www.imooc.com/course/list?c=cplusplus</a></p>            </div>\n            <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css\"/>\n                ",
			"keywords":["data_structure"]
		},
		{

			"title":"栈的实现",
			"content":"\n                    <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css\"/>\n            <div class=\"htmledit_views\">\n                \n<p><span style=\"color:rgb(51,51,51);font-family:arial, '宋体', sans-serif;font-size:14px;line-height:24px;text-indent:28px;\">栈（数据结构）：一种后进先出的数据结构</span></p>\n<p><span style=\"color:rgb(51,51,51);font-family:arial, '宋体', sans-serif;font-size:14px;line-height:24px;text-indent:28px;\">按照实现方式的不同可以分为顺序栈和链栈两种。</span></p>\n<p style=\"text-indent:28px;\"><span style=\"font-family:arial, '宋体', sans-serif;color:#333333;\"><span style=\"font-size:14px;line-height:24px;\">顺序栈：用顺序表实现，分配一个连续的存储空间用于存放栈中的元素</span></span></p>\n<p/>\n<pre class=\"cpp\">//置栈空\nvoid InitStack(Stack &amp;st)\n{\n\tst.top = -1;\n}\n\n//进栈,将元素x进到栈st中\nvoid Push(Stack &amp;st, ElemType x)\n{\n\tif (st.top == MaxSize-1)\t\t//栈溢出\n\t\treturn;\n\tst.s[++st.top] = x;\n}\n\n//出栈，将栈顶元素弹出保存到x中\nvoid Pop(Stack &amp;st, ElemType &amp;x)\n{\n\tif (st.top == -1)\t\t\t//栈为空\n\t\treturn;\n\tx = st.s[st.top--];\n}\n\n//取得栈顶元素，返回到x中\nvoid GetTop(Stack st, ElemType &amp;x)\n{\n\tif (st.top == -1)\t\t\t//栈为空\n\t\treturn;\n\tx = st.s[st.top];\n}\n\n//判断栈空\nbool IsStackEmpty(Stack st)\n{\n\tif (st.top == -1)\n\t\treturn true;\n\telse\n\t\treturn false;\n}</pre><br/><p/>\n<p><span style=\"color:rgb(51,51,51);font-family:arial, '宋体', sans-serif;font-size:14px;line-height:24px;text-indent:28px;\">链栈：栈的链式存储，本质上可以看做是只允许在表头进行插入和删除运算的单链表</span></p>\n<p><span style=\"color:rgb(51,51,51);font-family:arial, '宋体', sans-serif;font-size:14px;line-height:24px;text-indent:28px;\"/></p>\n<pre class=\"cpp\">//置栈空\nvoid InitStack(SNode *&amp;st)\n{\n\tst = NULL;\n}\n\n//进栈,将元素x进到栈st中\nvoid Push(SNode *&amp;st, ElemType x)\n{\n\tSNode *p;\n\tp = new SNode;\n\tp-&gt;data = x;\n\tp-&gt;next = NULL;\n\tif (st == NULL)\n\t\tst = p;\n\telse{\n\t\tp-&gt;next = st;\n\t\tst = p;\n\t}\n}\n\n//出栈，将栈顶元素弹出保存到x中\nvoid Pop(SNode *&amp;st, ElemType &amp;x)\n{\n\t\n\tif (st == NULL)\n\t\treturn;\n\tSNode *p = st;\n\tx = st-&gt;data;\n\tst = st-&gt;next;\n\tdelete p;\n}\n\n//取得栈顶元素，返回到x中\nvoid GetTop(SNode *st, ElemType &amp;x)\n{\n\tif (st == NULL)\n\t\treturn;\n\tx = st-&gt;data;\n}\n\n//判断栈空\nbool IsStackEmpty(SNode *st)\n{\n\tif (st == NULL)\n\t\treturn true;\n\telse \n\t\treturn false;\n}</pre><br/><br/><p/>\n            </div>\n                ",
			"keywords":["data_structure"]
		},
		{

			"title":"数据结构学习笔记",
			"content":"\n                    <div class=\"markdown_views\">\n                <h2 id=\"数据结构笔记\">数据结构笔记</h2>\n\n<p>主要是总结和学习<strong>大话数据结构</strong>中的知识点。</p>\n\n<p>参考：大话数据结构（程杰） <br/>\n博客：<a href=\"http://cj723.cnblogs.com/\">http://cj723.cnblogs.com/</a> <br/>\n豆瓣：<a href=\"https://book.douban.com/subject/6424904/\">https://book.douban.com/subject/6424904/</a></p>\n\n<h2 id=\"1-数据结构绪论\">1. 数据结构绪论</h2>\n\n<h4 id=\"11-什么是数据结构\">1.1 什么是数据结构？</h4>\n\n<p>它是一门研究非数值计算的程序设计问题的操作对象，以及它们之间关系和操作的相关问题；</p>\n\n<p><strong>程序设计＝数据结构＋算法</strong></p>\n\n\n\n<h4 id=\"12-基本概念和术语\">1.2 基本概念和术语</h4>\n\n<p>数据：描述客观事物的符号，计算机可操作的处理的符号集合； <br/>\n数据元素：是组成数据的，有一定意义的基本单位； <br/>\n数据项：一个数据元素可以由若干数据项组成，是数据不可分割的最小单位； <br/>\n数据对象：是性质相同的数据元素的集合，是数据的子集；</p>\n\n<p>从小到达: <strong>数据项-&gt;数据元素-&gt;数据对象-&gt;数据</strong></p>\n\n\n\n<h4 id=\"13-数据结构\">1.3 数据结构</h4>\n\n<p>相互之间存在一种或多种特定关系的数据元素的集合；</p>\n\n\n\n<h4 id=\"14-逻辑结构\">1.4 逻辑结构</h4>\n\n<p>集合结构：数据之间除了在同一集合中，无其它关系； <br/>\n线性结构：数据之间是一对一的关系； <br/>\n树形结构：存在一种一对多的层次关系； <br/>\n图形结构：存在多对多的关系；</p>\n\n\n\n<h4 id=\"15-物理结构\">1.5 物理结构</h4>\n\n<p>顺序存储结构：把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的； <br/>\n链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的；</p>\n\n\n\n<h2 id=\"2-算法\">2. 算法</h2>\n\n<p>定义：算法是解决特定问题求解步骤的描述，在计算机中为指令的有限序列，并且每条指令表示一个或多个操作； <br/>\n特性：有穷性，确定性，可行性，输入输出性； <br/>\n设计要求：正确性，可读性，健壮性，高效性和低存储量需求； <br/>\n度量方法：事后统计方法，事前分析估算方法； <br/>\n推导大Ｏ阶： <br/>\n1) 用常数１取代运行时间中的所有加法常数； <br/>\n2) 在修改之后的运行次数函数中，只保留最高阶项; <br/>\n3) 高阶项系数设为１;</p>\n\n<h3 id=\"各章节代码实现\">各章节代码实现</h3>\n\n<p>为方便理解学习，基本按照原书籍实现代码，包括： <br/>\n- 线性表（<a href=\"http://blog.csdn.net/panda_aj/article/details/54382416\">顺序结构</a>，<a href=\"http://blog.csdn.net/panda_aj/article/details/54585924\">链式结构</a>） <br/>\n- 栈（<a href=\"http://write.blog.csdn.net/postlist\">顺序结构</a>，链式结构） <br/>\n- 队列 <br/>\n- 串 <br/>\n- 树 <br/>\n- 图 <br/>\n- 查找 <br/>\n- 排序</p>\n\n<p>整理之后的代码文档，方便打印学习： <br/>\n下载地址：<a href=\"https://pan.baidu.com/s/1qY8QVhi\">https://pan.baidu.com/s/1qY8QVhi</a> <br/>\n提取密码：2sq6</p>            </div>\n            <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css\"/>\n                ",
			"keywords":["data_structure"]
		},
		{

			"title":"数据结构之开场篇",
			"content":"\n                    <div class=\"markdown_views\">\n                <p>最近在书堆里翻出一本落灰的的书《大话数据结构》。因为一直在用Java，C没怎么用过，忘的也差不多了，所以之前一看实现代码是用C语言写的，就不太想看。 <br/>\n既然这本书能在书堆里给翻出了，说明缘分还是不错的，就翻出了看看。 <br/>\n以后几篇，是用Java写的一些实现代码，有兴趣的朋友可以看看。</p>\n\n<ol>\n<li><a href=\"http://blog.csdn.net/qq_26411333/article/details/51804863\">数据结构-线性表</a></li>\n<li><a href=\"http://blog.csdn.net/qq_26411333/article/details/51809550\"> 数据结构-线性表之顺序储存（Java实现）</a></li>\n<li><a href=\"http://blog.csdn.net/qq_26411333/article/details/51813833\">数据结构-线性表之单链表（Java实现）</a></li>\n</ol>            </div>\n            <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css\"/>\n                ",
			"keywords":["data_structure"]
		},
		{

			"title":"数据结构-线性表",
			"content":"\n                    <div class=\"markdown_views\">\n                <h1 id=\"定义\">定义</h1>\n\n<p>《大话数据结构》上给的定义是：</p>\n\n<blockquote>\n  <p>线性表：零个或者多个数据元素组成的有限序列</p>\n</blockquote>\n\n<p>形象地来说就是所有的数据都按照一条线给串起来了。</p>\n\n\n\n<h1 id=\"分类\">分类</h1>\n\n<p><a href=\"https://img-blog.csdn.net/20160701235150402\">点击这里查看大图</a> <br/>\n<img src=\"https://img-blog.csdn.net/20160701235150402\" alt=\"线性表的分类\" title=\"\"/></p>\n\n<p>在线性表中，我会着重介绍顺序存储结构和单链表。双链表和单链表相比，理解起来还要简单一些，会粗略的给个实现；静态链表是一些计算机语言的限制所采取的权宜之策，这里不介绍了；循环链表跟单链表比较，只是首尾相连，会有一些特性，但并不是我们关注的重点。 <br/>\nJava中，顺序存储结构对应的典型是ArrayList,链式存储结构对应的典型是LinkedList。当然，Java中把增删查之类的操作已经封装好了，使用的时候，我们有时并不需要了解内部的原理。但作为一个名有研究精神的程序员，还是要了解这些东西的设计思路。</p>\n\n<p><strong>转载请标明出处</strong><a href=\"http://blog.csdn.net/qq_26411333/article/details/51804863\">http://blog.csdn.net/qq_26411333/article/details/51804863</a></p>            </div>\n            <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css\"/>\n                ",
			"keywords":["data_structure"]
		},
		{

			"title":"数据结构之栈(C实现)",
			"content":"\n                    <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css\"/>\n            <div class=\"htmledit_views\">\n                \n<p align=\"left\" style=\"margin-top:0px;margin-bottom:5px;padding-top:0px;padding-bottom:0px;border:0px;list-style:none;line-height:21px;color:rgb(70,70,70);font-family:simsun;font-size:14px;background-color:rgb(244,245,231);\">\n<strong>数据结构中的栈是什么</strong></p>\n<p align=\"left\" style=\"margin-top:0px;margin-bottom:5px;padding-top:0px;padding-bottom:0px;border:0px;list-style:none;line-height:21px;color:rgb(70,70,70);font-family:simsun;font-size:14px;background-color:rgb(244,245,231);\">\n举一个简单的例子：在往箱子里面放衣物的时候，放在最上面的衣物总是我们最后放上去的；而当我们从箱子里取出衣物的时候，总是最先拿出上面的。这就是现实生活中的栈。</p>\n<p align=\"left\" style=\"margin-top:0px;margin-bottom:5px;padding-top:0px;padding-bottom:0px;border:0px;list-style:none;line-height:21px;color:rgb(70,70,70);font-family:simsun;font-size:14px;background-color:rgb(244,245,231);\">\n准确的讲，栈就是一种可以实现“先进后出(或者叫后进先出)”的存储结构。</p>\n<p align=\"left\" style=\"margin-top:0px;margin-bottom:5px;padding-top:0px;padding-bottom:0px;border:0px;list-style:none;line-height:21px;color:rgb(70,70,70);font-family:simsun;font-size:14px;background-color:rgb(244,245,231);\">\n学过数据结构的人都知道：栈可以用两种方式来实现，一种方法是用数组实现栈，这种栈成为静态栈；另外一种方法是用链表实现栈，这种栈叫做动态栈。</p>\n<p align=\"left\" style=\"margin-top:0px;margin-bottom:5px;padding-top:0px;padding-bottom:0px;border:0px;list-style:none;line-height:21px;color:rgb(70,70,70);font-family:simsun;font-size:14px;background-color:rgb(244,245,231);\">\n栈中通常存放着程序的局部变量等。栈通常有出栈和入栈操作。</p>\n<p align=\"left\" style=\"margin-top:0px;margin-bottom:5px;padding-top:0px;padding-bottom:0px;border:0px;list-style:none;line-height:21px;color:rgb(70,70,70);font-family:simsun;font-size:14px;background-color:rgb(244,245,231);\">\n<strong>栈的结构</strong></p>\n<p align=\"left\" style=\"margin-top:0px;margin-bottom:5px;padding-top:0px;padding-bottom:0px;border:0px;list-style:none;line-height:21px;color:rgb(70,70,70);font-family:simsun;font-size:14px;background-color:rgb(244,245,231);\">\n空栈的结构：【其实就是栈顶和栈顶都指向一个无用的头结点】</p>\n<p align=\"left\" style=\"margin-top:0px;margin-bottom:5px;padding-top:0px;padding-bottom:0px;border:0px;list-style:none;line-height:21px;color:rgb(70,70,70);font-family:simsun;font-size:14px;background-color:rgb(244,245,231);\">\n<img src=\"http://s4.sinaimg.cn/middle/6975d67chbc49bbe9eee3&amp;690\" width=\"310\" height=\"152\" name=\"image_operate_32211332925041813\" alt=\"数据结构之栈(C实现)\" title=\"数据结构之栈(C实现)\" style=\"margin:0px;padding:0px;border:0px;list-style:none;\"/></p>\n<p align=\"left\" style=\"margin-top:0px;margin-bottom:5px;padding-top:0px;padding-bottom:0px;border:0px;list-style:none;line-height:21px;color:rgb(70,70,70);font-family:simsun;font-size:14px;background-color:rgb(244,245,231);\">\n存有结点的栈结构：【栈顶指针指向栈顶结点，栈底指针指向头结点】</p>\n<p align=\"left\" style=\"margin-top:0px;margin-bottom:5px;padding-top:0px;padding-bottom:0px;border:0px;list-style:none;line-height:21px;color:rgb(70,70,70);font-family:simsun;font-size:14px;background-color:rgb(244,245,231);\">\n<img src=\"http://s9.sinaimg.cn/middle/6975d67chbc49c217d398&amp;690\" width=\"375\" height=\"224\" name=\"image_operate_56501332925041965\" alt=\"数据结构之栈(C实现)\" title=\"数据结构之栈(C实现)\" style=\"margin:0px;padding:0px;border:0px;list-style:none;\"/></p>\n<p align=\"left\" style=\"margin-top:0px;margin-bottom:5px;padding-top:0px;padding-bottom:0px;border:0px;list-style:none;line-height:21px;color:rgb(70,70,70);font-family:simsun;font-size:14px;background-color:rgb(244,245,231);\">\n<strong>栈的实现</strong></p>\n<p align=\"left\" style=\"margin-top:0px;margin-bottom:5px;padding-top:0px;padding-bottom:0px;border:0px;list-style:none;line-height:21px;color:rgb(70,70,70);font-family:simsun;font-size:14px;background-color:rgb(244,245,231);\">\n下面是用C实现的一个栈结构的源码及详细注释：</p>\n<p align=\"left\" style=\"margin-top:0px;margin-bottom:5px;padding-top:0px;padding-bottom:0px;border:0px;list-style:none;line-height:21px;color:rgb(70,70,70);font-family:simsun;font-size:14px;background-color:rgb(244,245,231);\">\n#include&lt;stdio.h&gt;<br/>\n#include&lt;stdlib.h&gt;<br/>\n#include&lt;malloc.h&gt;<br/>\n//定义结点结构体<br/>\ntypedef struct Node<br/>\n{<br/>\n int data;    //内容<br/>\n struct Node * pNext; //指向下一结点的指针<br/>\n} NODE, * PNODE;   //NODE等价于struct Node, PNODE等价于struct Node *<br/>\n//定义栈的结构体<br/>\ntypedef struct Stack<br/>\n{<br/>\n PNODE pTop;    //栈顶结点<br/>\n PNODE pBottom;   //栈底结点<br/>\n} STACK, * PSTACK;   //STACK等价于struct Stack, PSTACK等价于struct Stack *<br/>\n//函数声明<br/>\nvoid initStack(PSTACK pStack);    //对栈进行初始化的函数<br/>\nvoid pushStack(PSTACK pStack, int val);  //入栈的函数<br/>\nbool popStack(PSTACK pStack, int * pVal);//出栈的函数，*pVal用来保存出栈的元素内容<br/>\nvoid traverseStack(PSTACK pStack);   //遍历栈的函数<br/>\nbool isEmpty(PSTACK pStack);    //判断栈是否为空的函数<br/>\nvoid clearStack(PSTACK pStack);   //清空栈的函数<br/>\nint main(void)<br/>\n{<br/>\n STACK stack;   //定义一个栈变量,STACK等价于struct Stack<br/>\n int val;    //用来保存出栈的内容<br/>\n initStack(&amp;stack);  //调用栈的初始化函数<br/>\n pushStack(&amp;stack, 10); //调用入栈的函数<br/>\n pushStack(&amp;stack, 20);<br/>\n pushStack(&amp;stack, 30);<br/>\n pushStack(&amp;stack, 50);<br/>\n traverseStack(&amp;stack); //调用遍历栈的函数<br/>\n //调用出栈的函数<br/>\n if(popStack(&amp;stack, &amp;val))<br/>\n  printf(\"出栈成功，出栈的元素值为：%d\\n\", val);<br/>\n else<br/>\n  printf(\" 出栈失败!\");<br/>\n //调用清空栈的函数<br/>\n clearStack(&amp;stack);<br/>\n traverseStack(&amp;stack); //调用遍历栈的函数<br/>\n system(\"pause\");<br/>\n return 0;<br/>\n}<br/><br/>\nvoid initStack(PSTACK pStack)<br/>\n{<br/>\n //创建一个空结点，让pTop指向它<br/>\n pStack-&gt;pTop = (PNODE)malloc(sizeof(NODE));<br/>\n if(NULL != pStack-&gt;pTop)<br/>\n {<br/>\n  //将pBottom也指向空节点<br/>\n  pStack-&gt;pBottom = pStack-&gt;pTop;<br/>\n  //清空空结点的指针域<br/>\n  pStack-&gt;pTop-&gt;pNext = NULL;</p>\n<p align=\"left\" style=\"margin-top:0px;margin-bottom:5px;padding-top:0px;padding-bottom:0px;border:0px;list-style:none;line-height:21px;color:rgb(70,70,70);font-family:simsun;font-size:14px;background-color:rgb(244,245,231);\">\n }<br/>\n else      //如果内存分配失败<br/>\n {<br/>\n  printf(\"内存分配失败!程序退出!\\n\");<br/>\n  exit(-1);<br/>\n }<br/>\n return;<br/>\n}<br/><br/>\nvoid pushStack(PSTACK pStack, int val)<br/>\n{<br/>\n //动态创建一个新结点<br/>\n PNODE pNew = (PNODE)malloc(sizeof(NODE));<br/>\n //设置新结点的数据域的值<br/>\n pNew-&gt;data = val;<br/>\n //将新结点的指针域指向之前建的空节点<br/>\n pNew-&gt;pNext = pStack-&gt;pTop;   //pStack-&gt;pTop不能换成pStack-&gt;pBottom<br/>\n //pTop指向新的结点<br/>\n pStack-&gt;pTop = pNew;<br/>\n return;<br/>\n}<br/><br/>\nbool popStack(PSTACK pStack, int * pVal)<br/>\n{<br/>\n if(isEmpty(pStack))<br/>\n {<br/>\n  return false;<br/>\n }<br/>\n else<br/>\n {<br/>\n  //先保存栈顶元素的地址，然后将pTop指向下一元素,最后释放之前栈顶元素的内存<br/>\n  PNODE rNode = pStack-&gt;pTop;<br/>\n  *pVal = rNode-&gt;data;<br/>\n  pStack-&gt;pTop = rNode-&gt;pNext;<br/>\n  free(rNode);<br/>\n  rNode = NULL;<br/>\n  return true;<br/>\n }</p>\n<p align=\"left\" style=\"margin-top:0px;margin-bottom:5px;padding-top:0px;padding-bottom:0px;border:0px;list-style:none;line-height:21px;color:rgb(70,70,70);font-family:simsun;font-size:14px;background-color:rgb(244,245,231);\">\n}<br/><br/>\nvoid traverseStack(PSTACK pStack)<br/>\n{<br/>\n //将栈顶赋给一个临时结点,因为在遍历栈的时候不能销毁栈<br/>\n PNODE pNode = pStack-&gt;pTop;<br/>\n //循环遍历栈,直到栈底<br/>\n while(pStack-&gt;pBottom != pNode )<br/>\n {<br/>\n  printf(\"%d  \", pNode-&gt;data);<br/>\n  pNode = pNode-&gt;pNext;<br/>\n }<br/>\n printf(\"\\n\");<br/>\n return;<br/>\n}<br/><br/>\nbool isEmpty(PSTACK pStack)<br/>\n{<br/>\n if(pStack-&gt;pTop == pStack-&gt;pBottom)<br/>\n  return true;<br/>\n else<br/>\n  return false;<br/>\n}<br/><br/>\nvoid clearStack(PSTACK pStack)<br/>\n{ //栈为空，则退出该函数<br/>\n if(isEmpty(pStack))<br/>\n {<br/>\n  return;<br/>\n }<br/>\n else<br/>\n { <br/>\n  //两个结点指针变量用来释放栈中元素的内存<br/>\n  PNODE p = pStack-&gt;pTop;<br/>\n  PNODE q = NULL;<br/>\n  //循环释放内存<br/>\n  while(p != pStack-&gt;pBottom)<br/>\n  {<br/>\n   q = p-&gt;pNext;<br/>\n   free(p);<br/>\n   p = q;<br/>\n  }<br/>\n  //将栈顶和栈底指向同一个指针域为空的结点<br/>\n  pStack-&gt;pTop = pStack-&gt;pBottom;<br/>\n  return;<br/>\n }<br/>\n}</p>\n<p align=\"left\" style=\"margin-top:0px;margin-bottom:5px;padding-top:0px;padding-bottom:0px;border:0px;list-style:none;line-height:21px;color:rgb(70,70,70);font-family:simsun;font-size:14px;background-color:rgb(244,245,231);\">\n<strong>栈的典型应用</strong></p>\n<p align=\"left\" style=\"margin-top:0px;margin-bottom:5px;padding-top:0px;padding-bottom:0px;border:0px;list-style:none;line-height:21px;color:rgb(70,70,70);font-family:simsun;font-size:14px;background-color:rgb(244,245,231);\">\n生产消费模型常用栈来实现。生产者生产的东西都放入栈中，然后消费者从栈中依次取出东西，当栈顶和栈底指向都指向首结点时，生产的东西就被消耗光了。</p>\n            </div>\n                ",
			"keywords":["data_structure"]
		},
		{

			"title":"数据结构相关概念",
			"content":"\n                    <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css\"/>\n            <div class=\"htmledit_views\">\n                \n<p>一. 什么是数据结构？</p>\n<div>     数据结构是计算机存储、组织数据的方式，是指相互之间存在一种或多种特定关系的数据元素的集合。包括数据的逻辑结构，数据的存储结构和数据运算结构。</div>\n<div>     1.  逻辑结构：(1)  集合 (2)  线性结构 (3)   树形结构  (4)   图形结构 </div>\n<div>     2.  存储结构：(1)  顺序存储 (2)   链式存储  (3)   索引存储  (4)   散列存储  </div>\n<div>     3.  数据运算结构：(1)   新建  (2)   插入  (3)   查找  (4)   删除  (5)   合并  (6)   排序  (7)   统计   (8)   计算  (9)   修改  (10)   遍历</div>\n<p>二. 数据结构相关概念及作用</p>\n<p>     1.  基本概念</p>\n<p>          (1).  数据元素： 数据的基本单位</p>\n<p>          (2).  数据项： 数据不可再分的最小单位</p>\n<p>          (3).  数据对象： 具有相同性质的数据元素的集合</p>\n<p>     2.  作用</p>\n<p>          (1).  逻辑与存储的结合使数据存储更合理整齐，使用时更加方便。</p>\n<p>          (2).  逻辑结构的便捷减少运算的时间复杂度，降低空间复杂度。 </p>\n<p>三. 数据结构的分类</p>\n<p>     1.  集合 ：指具有某种特定性质的具体的或抽象的对象汇总成的集体，这些对象称为该集合的<strong>元素，</strong>集合中元素的数目称为集合的基数。</p>\n<p>          (1).    分类</p>\n<p>                 <img src=\"https://img-blog.csdn.net/20170926152840208?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenluMTk5NTAxMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"/> \n</p>\n<p>          (2).    表示法</p>\n<p>                <img src=\"https://img-blog.csdn.net/20170926152828185?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenluMTk5NTAxMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"/>               \n</p>\n<p>          (3).    特性</p>\n<p>                 <img src=\"https://img-blog.csdn.net/20170926152805128?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenluMTk5NTAxMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"/></p>\n<p>          (4).    运算律     </p>\n<p>                 <img src=\"https://img-blog.csdn.net/20170926152755940?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenluMTk5NTAxMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"/></p>\n<p>     2.  线性结构 ：是一个有序数据元素的集合，表现为一对一的关系。</p>\n<p>          (1).   特性</p>\n<p>                  a.    集合中必存在唯一的第一个元素</p>\n<p>                  b.    集合中必存在唯一的最后一个元素</p>\n<p>                  c.    除最后一个元素外，每个元素均有唯一的后继</p>\n<p>                  d.    除第一个元素外，每个元素均有唯一的前驱</p>\n<p>          (2).   常见线性结构</p>\n<p>                  a. 数组   b. 单链表   c. 双向链表    d. 栈    e. 队列     f. 双端队列    g. 循环队列    h. 循环链表</p>\n<p>     3.  树形结构 ：是数据元素之间存在着一对多的树形关系的数据结构。</p>\n<p>          (1).   相关术语</p>\n<p>     <img src=\"https://img-blog.csdn.net/20170926152724517?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenluMTk5NTAxMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"/></p>\n<p>          (2).   常见树形结构</p>\n<p>                  a.  二叉树   b.  红黑树   c.  AVL 树    d.   BST 树   e.  B树   f.   B+ 树   g.  B*树    h.   Trie树\n</p>\n<p>     4.  图形结构 ：每个结点的前驱结点数和后续结点数可以任意多个的网状结构。</p>\n<p>          (1).   基本概念</p>\n<p>                <img src=\"https://img-blog.csdn.net/20170926152359538?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenluMTk5NTAxMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"/></p>\n<p>          (2).   图的类型</p>\n<p>                 <img src=\"https://img-blog.csdn.net/20170926152347003?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenluMTk5NTAxMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"/>   \n</p>\n<p>          (3).   矩阵表示方法</p>\n<p>                   a. 无向图的关联矩阵，设无向图G=&lt;V,E&gt;, V={v1, v2, …, vn}, E={e1, e2, …, em}, 令mij为vi与ej的关联次数，称(mij)nm为G的关联矩阵，记为M(G).\n</p>\n<p><br/></p>\n<p>                     <img src=\"https://img-blog.csdn.net/20170926152334618?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenluMTk5NTAxMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"/></p>\n<p>                   b. 有向图的关联矩阵</p>\n<p>                  <img src=\"https://img-blog.csdn.net/20170926152121644?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenluMTk5NTAxMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"/></p>\n<p>                   c. 有向图的邻接矩阵</p>\n<p>                     <img src=\"https://img-blog.csdn.net/20170926152110363?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenluMTk5NTAxMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"/>   \n</p>\n<p>                        d. 有向图的可达矩阵           </p>\n<p>                            <img src=\"https://img-blog.csdn.net/20170926151958259?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvenluMTk5NTAxMjA=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"\"/></p>\n<p><br/></p>\n<p>                   </p>\n<div>﻿﻿</div>\n            </div>\n                ",
			"keywords":["data_structure"]
		}
	]
}
