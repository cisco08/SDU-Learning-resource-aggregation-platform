{
	"arr" : [
		{

			"title":"离散数学 - CSDN博客",
			"content":"\n                    <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css\"/>\n            <div class=\"htmledit_views\">\n                <div>整个下午连续上3节离散数学，睡了半节课，玩了一节课手机，发了一节课呆，没学到什么，学离散数学有什么用？</div>            </div>\n                ",
			"keywords":["discrete_math"]
		},
		{

			"title":"离散数学中Warshall算法简析 - CSDN博客",
			"content":"\n                    <div class=\"markdown_views\">\n                <h2 id=\"离散数学中warshall算法简析\">离散数学中Warshall算法简析</h2>\n\n<pre><code>最近学了离散数学的图论，突然感觉离散数学的作用十分强大，相信学好离散数学中的算法，编程的魅力也不言而喻。闲话不多说，这篇博客中记录的是Warshall算法的简单解析及C++代码实现。\n问题引出：在一个图结构中，常常需要找两个节点之间有没有一条通路（通路长任意），也就是任意两点之间的可达情况，我们很自然会联想到用邻接矩阵来求可达矩阵，从而得出两点之间的可达情况。如：\n</code></pre>\n\n<p><img title=\"\" alt=\"这里写图片描述\" src=\"https://img-blog.csdn.net/20170926132238079?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3ODE4MDgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\"/> <br/>\n在这个图中，可以写出其邻接矩阵为： <br/>\n0 1 1 1 <br/>\n1 0 0 0 <br/>\n1 0 0 1 <br/>\n1 0 1 0 <br/>\n记为矩阵A。那么很明显在图中，V2与V1存在直接通路（即长是1），V1与V4之间也有直接通路，但是V2与V4之间没有长度是1的通路，但是存在边长是2的通路，然而这在矩阵A中没有相应的体现，因为矩阵元素M（2，4） == 0，于是我们找任意图中一点Vk，只要满足V（2k）乘以V（k4）！= 0[注意：括号中指的是下标]，则证明V2可以借助Vk（此图中指的是V1）与V4连通。 <br/>\n以此类推，当想得到任意一点与其他各点通路是2的连接的时候（这里指的是Vi，Vj两点）就可以逐个计算满足：V（ik）乘以V（kj）！= 0的，而V（ik）乘以V（kj）正好是求矩阵A乘以矩阵A的过程，所以矩阵A的平方就可以反应出通过边长为2图中各点之件的可达情况，以此类推，A的3次方、A的4次方……,分别表示了边长是3、边长是4……的可达情况，现在把所有可能长度的通路可达情况加起来（即A1方 + A2方 + A3方 +……），就可以得到近似可达矩阵。 <br/>\n为什么这里说是近似的可达矩阵？因为一个复杂的图中（如互联网模型），通路的长度成千上百都可能，那到底应该加到A的几次方才算有保证呢？很明显，这个算法存在局限性，对于简单的图还凑合，复杂的图就没有全面的保障了。Warshall算法就是为了求一个可靠的可达矩阵。 <br/>\n    算法的自己的语言描述：依次遍历邻接矩阵中的所有元素（M[i,j]），比如按照先列后行进行，如果M[i，j] ！= 0，那么就把i行加到第j行上。 <br/>\n    算法的代码描述：</p>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs cpp\"><span class=\"hljs-preprocessor\">#include &lt;iostream&gt;</span>\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-built_in\">std</span>;\n<span class=\"hljs-preprocessor\">#define COLUMNS 4</span>\n<span class=\"hljs-preprocessor\">#define ROWS 4</span>\n<span class=\"hljs-keyword\">void</span> Warshall(<span class=\"hljs-keyword\">int</span> nearArra[ROWS][COLUMNS]);\n<span class=\"hljs-keyword\">int</span> main()\n{\n    <span class=\"hljs-comment\">//定义邻接矩阵</span>\n    <span class=\"hljs-comment\">//此处手动输入图的矩阵表示数据</span>\n    <span class=\"hljs-keyword\">int</span> nearArra[<span class=\"hljs-number\">4</span>][<span class=\"hljs-number\">4</span>] = { { <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> },\n    { <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span> },\n    { <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> },\n    { <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> } };\n    Warshall(nearArra);\n    <span class=\"hljs-comment\">//输出...</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; <span class=\"hljs-number\">4</span>; j++) {\n            <span class=\"hljs-keyword\">if</span> (nearArra[i][j] != <span class=\"hljs-number\">0</span>) {\n                <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-string\">\" \"</span>;\n            }\n            <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-built_in\">cout</span> &lt;&lt; <span class=\"hljs-number\">0</span> &lt;&lt; <span class=\"hljs-string\">\" \"</span>;\n            }\n        }\n        <span class=\"hljs-built_in\">cout</span> &lt;&lt; endl;\n    }\n\n    system(<span class=\"hljs-string\">\"pause\"</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-keyword\">void</span> Warshall(<span class=\"hljs-keyword\">int</span> nearArra[ROWS][COLUMNS]) {\n    <span class=\"hljs-comment\">//Warshall算法求运用邻接矩阵求图中所有可能的通路（即可达矩阵）</span>\n    <span class=\"hljs-comment\">//参数 ： 图的邻接矩阵</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; COLUMNS; i++) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; ROWS; j++) {\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">0</span> != nearArra[j][i]) {\n                <span class=\"hljs-comment\">//若此位置是1，此位置对应的列序号的行（即i）加到当前位置的行（即j）上</span>\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; COLUMNS; k++) {\n                        nearArra[j][k] += nearArra[i][k];\n                    }\n                }\n            }\n        }\n    }</code></pre>\n\n<p>还是代码更容易理解些，就是首先运用于二重循环做矩阵的遍历，然后如果满足条件就开始执行I行加到j行的操作，最终在主函数中输出。（注意这里是给定一个矩阵）代码输入  <br/>\n<img title=\"\" alt=\"原来的矩阵\" src=\"https://img-blog.csdn.net/20170926131951295?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3ODE4MDgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\"/>。经过算法处理后矩阵是：</p>\n\n<p><img title=\"\" alt=\"处理后的矩阵\" src=\"https://img-blog.csdn.net/20170926132111148?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VpeGluXzM3ODE4MDgx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\"/>当然这只是单纯的方法，他有许多其他的应用，后续研究时会继续更新，有错误和疑问及时讨论，希望大家支持！最后附上一个不错的关文章： <br/>\n<a href=\"https://wenku.baidu.com/view/3c292a7827284b73f2425000.html\">Warshall算法的C语言实现</a></p>            </div>\n            <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css\"/>\n                ",
			"keywords":["discrete_math"]
		},
		{

			"title":"布尔代数与计算机 - CSDN博客",
			"content":"\n                    <div class=\"markdown_views\">\n                <p>在大一时学习离散数学学时，就看到一句话：计算机=离散数学+微电子技术，当时并没有真正理解这句话，只是随后学习数据结构时，学习了树，图等数据结构才开始逐渐了解到这句话一部分内涵。 <br/>\n最近在学习《计算机系统要素》这本书时，才开始理解了离散数学与计算机硬件结构的关系。 <br/>\n离散数学的分支布尔代数在电子技术上的应用就是数字电路。数字电路的结构通常都可以化简为布尔代数的表达式。 <br/>\n而计算机就是依赖于布尔代数来构建了一些复杂的模块，例如ALU。 <br/>\n在《计算机系统要素》中，ALU就是一系列布尔函数的集合，通过控制信号来选择函数的执行顺序。</p>            </div>\n            <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css\"/>\n                ",
			"keywords":["discrete_math"]
		},
		{

			"title":"《离散数学及其应用》读书笔记【一】逻辑和证明 - CSDN博客",
			"content":"\n                    <div class=\"markdown_views\">\n                <p>对于一个经常计算机打交道的程序员来说 有两门知识及其重要一个是离散数学一个是数据结构</p>\n\n<p>离散数学让我们可以用最接近计算机运行的方式去处理编写代码 对思路有着及其重要的指导作用 <br/>\n数据结构则可以让我们了解计算机运行时数据的结构 更好的处理问题等</p>\n\n<p>最近这段时间正好有空就把《离散数学及其应用这本书》打算看几遍 看的是中文版对比英文版有很大删减 </p>\n\n<p>在接触离散数学前对 或与非 已经有很多的接触 但并未正式的系统学习 所以今年计划把一些基础性的知识补习一下 为以后发展做好基础知识储备</p>\n\n\n\n<h2 id=\"命题逻辑\">命题逻辑</h2>\n\n<p><strong>命题</strong> <br/>\n命题：是一个或真或假的陈述句只有一种状态 <br/>\n用字母代表命题元（命题变量）</p>\n\n<p><strong>析取 合取 非 </strong>（或与非） <br/>\n可以简单的记忆为（具体真值可以参考真值表）： <br/>\n合取：当两者同真时才为真（真1）符号：∧（当初记忆时为了和∨区别 合字 上面的的人正好和∧相似 这样就很容易记住了） <br/>\n析取：有一者为真即为真（真3）符号：∨ <br/>\n非：非真为假 非假为真（取反）（真2）符号：¬ <br/>\n异或：两者相反即为真（真2 =析取-合取）符号：¬</p>\n\n<p><strong>条件运算</strong> <br/>\n可以简单的记忆为（具体真值可以参考真值表）： <br/>\n单条件运算：p→q时 只有p为真q为假时为假 其余为真（真3） 符号：→（读作:若…则 …） <br/>\np→q：逆 倒置 反 （包含） <br/>\n逆: q→p （pq位置互换（逆））, <br/>\n倒置 : ┐q →┐p（先pq位置互换在取反（与p→q总是相同的真值）） <br/>\n反:┐q→┐p（取反）</p>\n\n<p>双条件运算：p↔q是  当两者状态相同时为真 其余为假 亦p,q等价（真2）符号：⇔（读作:当且仅当） </p>\n\n<p><strong>逻辑运算优先级（从高往低）</strong> <br/>\n非 合取 析取 单条件 双条件 (建议用括号包围)</p>\n\n\n\n<h2 id=\"命题等价\">命题等价</h2>\n\n<p>定义1：复合命题称为永真式（或重言式） 真值永远为假的复合命题称为矛盾 <br/>\n定义2：（等价的符号&lt;=&gt;） <br/>\n<strong>各种逻辑等价的关系推导及罗列</strong> <br/>\n<img src=\"https://img-blog.csdn.net/20160628154745999\" alt=\"逻辑等价的关系\" title=\"\"/> <br/>\n对与各种逻辑等价不建议死记 学过命题逻辑后会很容易的推导出来 <br/>\n这里对吸收律做证明</p>\n\n\n\n<pre class=\"prettyprint\"><code class=\" hljs xml\">1.p<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">=</span>&gt;</span>p∨F\n2.F<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">=</span>&gt;</span>(q∧┐q)\n3.p<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">=</span>&gt;</span>p∨F<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">=</span>&gt;</span>p∨(q∧┐q)<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">=</span>&gt;</span>(p∨q)∧(p∨┐q)\n4.p∧(p∨q)<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">=</span>&gt;</span>(p∨q)∧(p∨┐q)∧(p∨q)<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">=</span>&gt;</span>(p∨q)∧(p∨┐q)<span class=\"hljs-tag\">&lt;<span class=\"hljs-title\">=</span>&gt;</span>p</code></pre>\n\n<p>逻辑等价：在所有可能的情况下都有相同真值的两个复合命题称为逻辑等价（一个简单的例子：p→q和┐p∨q逻辑等价） <br/>\n析取范式，合取范式的定义</p>\n\n\n\n<h2 id=\"谓词和量词\">谓词和量词</h2>\n\n<p>量词用来定义在域内取值范围 （可看做作用 变量 的范围；量词描述范围可以理解为程序中的数据类型等描述范围的概念） <br/>\n谓词用来描述（可看做方法）</p>\n\n<p><strong>量词的分类：</strong> <br/>\n全称量词 即所有 （符号表示：∀） <br/>\n存在量词 即存在 （符号表示：∃）（唯一量词 不常用： 符号表示： ∃!） <br/>\n<strong>量词的优先级</strong>：比逻辑运算具有更高的优先级 <br/>\n量词的德摩根定律 <br/>\n量词的语义化翻译 <br/>\n量词的嵌套</p>\n\n\n\n<h2 id=\"推理规则\">推理规则</h2>\n\n<p><strong>定义1</strong>：命题逻辑中的一个论证是一连串的命题 除了论证中最后一个命题外都叫前提 最后的那个命题叫做结论 当它所有的前提为真意味着结论为真时 一个论证是有效的</p>\n\n<p><strong>推理规则表</strong> <br/>\n<img src=\"https://img-blog.csdn.net/20160629100156857\" alt=\"推理规则表\" title=\"\"/></p>\n\n<p><strong>带量词的推理规则：</strong> <br/>\n全称例示：从全部得出任意个体（由大见小） <br/>\n全称生成：从任意个体得出全部（由小见大） <br/>\n存在例示：从存在得出某个个体（部分得出个体） <br/>\n存在生成：从某个个体得出存在（个体得出部分）</p>\n\n<h2 id=\"一些证明及推理规则的展示\">一些证明及推理规则的展示</h2>\n\n<p>这里就不在赘述 </p>            </div>\n            <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css\"/>\n                ",
			"keywords":["discrete_math"]
		},
		{

			"title":"floyd求传递闭包 - CSDN博客",
			"content":"\n                    <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css\"/>\n            <div class=\"htmledit_views\">\n                \n<p>传递闭包是我们在离散数学里学的东西。</p>\n<p>而用floyd算法求这个是方便的，显然的，通俗易懂的。</p>\n<p>贴代码。</p>\n<p/><pre class=\"cpp\">void Floyd()  \n{  \n    for(int k=1; k&lt;=n; k++)  \n        for(int i=1; i&lt;=n; i++)  \n            if(mp[i][k])  \n                for(int j=1; j&lt;=n; j++)  \n                    if(mp[k][j])  \n                        mp[i][j] = 1;  \n}  </pre><br/><br/>            </div>\n                ",
			"keywords":["discrete_math"]
		},
		{

			"title":"离散数学——树 - CSDN博客",
			"content":"\n                    <div class=\"markdown_views\">\n                <h2 id=\"树\">树</h2>\n\n<hr/>\n\n<p>本人是新人，对树的概念还是不太清楚，故写个学习概念的文章，来帮助自己学习树这一数据结构。</p>\n\n<hr/>\n\n<p>定义1.树是没有简单回路的连通无向图。 <br/>\n定理1.一个无向图是树当且仅当在它的每对顶点间存在唯一简单回路。 <br/>\n定义2.有根树是指一个顶点（指所有节点）作为根并且每条边的方向都离开根的树。 <br/>\n<img src=\"https://img-blog.csdn.net/20161209225220765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXN0b241MTI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\"/> <br/>\n<a href=\"http://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=%E6%A0%91%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;step_word=&amp;hs=0&amp;pn=3&amp;spn=0&amp;di=50803261520&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0,0&amp;istype=0&amp;ie=utf-8&amp;oe=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=undefined&amp;cs=875565228,81094927&amp;os=4129699680,2756185878&amp;simid=4075110645,549227620&amp;adpicid=0&amp;ln=1891&amp;fr=&amp;fmq=1481294094330_R&amp;fm=&amp;ic=undefined&amp;s=undefined&amp;se=&amp;sme=&amp;tab=0&amp;width=&amp;height=&amp;face=undefined&amp;ist=&amp;jit=&amp;cg=&amp;bdtype=0&amp;oriquery=&amp;objurl=http://wenwen.soso.com/p/20101027/20101027223540-1463998862.jpg&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Fojgojg_z&amp;e3Bf5f5_z&amp;e3Bv54AzdH3FzAzdH3Fqdn8ndll0a_z&amp;e3Bip4&amp;gsm=0&amp;rpstart=0&amp;rpnum=0\">图片出处</a></p>\n\n<p>关于孩子，父母与深度和高度什么的，用两张图就能解决的就不多赘述： <br/>\n<img src=\"https://img-blog.csdn.net/20161209230033214?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXN0b241MTI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\"/> <br/>\n<a href=\"http://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=%E6%A0%91%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;step_word=&amp;hs=0&amp;pn=8&amp;spn=0&amp;di=183363813380&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0,0&amp;istype=0&amp;ie=utf-8&amp;oe=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=undefined&amp;cs=3870269454,1176758877&amp;os=1747192153,1125569655&amp;simid=0,0&amp;adpicid=0&amp;ln=1891&amp;fr=&amp;fmq=1481294094330_R&amp;fm=&amp;ic=undefined&amp;s=undefined&amp;se=&amp;sme=&amp;tab=0&amp;width=&amp;height=&amp;face=undefined&amp;ist=&amp;jit=&amp;cg=&amp;bdtype=0&amp;oriquery=&amp;objurl=http://www.cppblog.com/images/cppblog_com/guogangj/ds_tree_concept_f.png&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z&amp;e3Bvrrks52_z&amp;e3Bv54AzdH3F2752wg23AzdH3Fw6vitejAzdH3FdaalAzdH3F8aAzdH3F8mAzdH3Flb00d_z&amp;e3Bip4s&amp;gsm=0&amp;rpstart=0&amp;rpnum=0\">图片出处</a> <br/>\n<img src=\"https://img-blog.csdn.net/20161209223650821?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXN0b241MTI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"\" title=\"\"/> <br/>\n<a href=\"http://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=%E6%A0%91%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;step_word=&amp;hs=0&amp;pn=1&amp;spn=0&amp;di=120204420600&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0,0&amp;istype=0&amp;ie=utf-8&amp;oe=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=undefined&amp;cs=1490322406,2141282547&amp;os=394968457,2910753406&amp;simid=0,0&amp;adpicid=0&amp;ln=1891&amp;fr=&amp;fmq=1481294094330_R&amp;fm=&amp;ic=undefined&amp;s=undefined&amp;se=&amp;sme=&amp;tab=0&amp;width=&amp;height=&amp;face=undefined&amp;ist=&amp;jit=&amp;cg=&amp;bdtype=0&amp;oriquery=&amp;objurl=http://b.hiphotos.baidu.com/zhidao/pic/item/94cad1c8a786c917c685653dc93d70cf3bc7572b.jpg&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Fzit1w5_z&amp;e3Bkwt17_z&amp;e3Bv54AzdH3Fq7jfpt5gAzdH3F8nb9dmbam_z&amp;e3Bip4s&amp;gsm=0&amp;rpstart=0&amp;rpnum=0\">图片出处</a></p>\n\n<p>定义3.若有根树的每个内点（指除了叶之外的所有点）都有不超过m个孩子，则它为m叉树，若该树的每个内点都恰好有m个孩子，则称它为满m叉树。把m = 2的m叉树称为二叉树。</p>\n\n<p>如第一幅图就是个二叉树。 <br/>\n下图就是个满二叉树： <br/>\n<img src=\"https://img-blog.csdn.net/20161209231110058?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXN0b241MTI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\"/> <br/>\n<a href=\"http://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=%E6%A0%91%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;step_word=&amp;hs=0&amp;pn=28&amp;spn=0&amp;di=45932965980&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0,0&amp;istype=0&amp;ie=utf-8&amp;oe=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=undefined&amp;cs=2965650210,1184119926&amp;os=3002430394,1358683259&amp;simid=0,0&amp;adpicid=0&amp;ln=1891&amp;fr=&amp;fmq=1481294094330_R&amp;fm=&amp;ic=undefined&amp;s=undefined&amp;se=&amp;sme=&amp;tab=0&amp;width=&amp;height=&amp;face=undefined&amp;ist=&amp;jit=&amp;cg=&amp;bdtype=0&amp;oriquery=&amp;objurl=http://7xospc.com1.z0.glb.clouddn.com/6-5-5.jpg&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Fooo_z&amp;e3Bzyk7s75_z&amp;e3Bv54AzdH3F275xfAzdH3Fg5pjAzdH3Fd9dd8l&amp;gsm=0&amp;rpstart=0&amp;rpnum=0\">图片出处</a></p>\n\n<p><strong>有序根树</strong>的每个内点的孩子都从左到右依次递增： <br/>\n<img src=\"https://img-blog.csdn.net/20161209233417745?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXN0b241MTI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\"/> <br/>\n自己p的图</p>\n\n<p>在有序二叉树中，左边的更小值称为左子，右边的较大值称为右子： <br/>\n<img src=\"https://img-blog.csdn.net/20161209233854971?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXN0b241MTI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\"/> <br/>\n<a href=\"http://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=%E6%A0%91%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;step_word=&amp;hs=0&amp;pn=7&amp;spn=0&amp;di=24794729300&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0,0&amp;istype=2&amp;ie=utf-8&amp;oe=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=-1&amp;cs=3754463516,818217079&amp;os=645429949,2857620371&amp;simid=0,0&amp;adpicid=0&amp;ln=1891&amp;fr=&amp;fmq=1481297802581_R&amp;fm=result&amp;ic=0&amp;s=undefined&amp;se=&amp;sme=&amp;tab=0&amp;width=&amp;height=&amp;face=undefined&amp;ist=&amp;jit=&amp;cg=&amp;bdtype=0&amp;oriquery=&amp;objurl=http://cfanz.cn/uploads/png/2014/07/02/13/T21314GA97.png&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Fvuwgz_z&amp;e3BvgAzdH3Ftg1jx_z&amp;e3Brir?v=w6ptvsj&amp;w=6jw1&amp;t1=80da00&amp;gsm=0&amp;rpstart=0&amp;rpnum=0\">图片出处</a> <br/>\n注意，此树必须有序。</p>\n\n<p>定理2.带有n个顶点的树含有n - 1条边。 <br/>\n定理3.带有i个内点的满m叉树含有n = m * i + 1个顶点。 <br/>\nps：根是内点，除非它是图中唯一的顶点，在这种情况下，它也是叶。</p>\n\n<p>定理4.一个满m叉树若有： <br/>\n（i）n个顶点，则有i = (n-1) / m个内点和l = [(m-1) * n + 1] / m个叶； <br/>\n（ii）i个内点，则有n = m * i + 1个顶点和l = (m-1) * i + 1个叶； <br/>\n（iii）l个树叶，则有n = (m * l - 1) / (m - 1)个顶点和i = (l - 1) / (m - 1)个内点；</p>\n\n<p>平衡m叉树：表示某树T的所有叶大约在同一层上（+-1）： <br/>\n<img src=\"https://img-blog.csdn.net/20161209225220765?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXN0b241MTI4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\" title=\"\"/> <br/>\n<a href=\"http://image.baidu.com/search/detail?ct=503316480&amp;z=0&amp;ipn=d&amp;word=%E6%A0%91%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84&amp;step_word=&amp;hs=0&amp;pn=3&amp;spn=0&amp;di=50803261520&amp;pi=0&amp;rn=1&amp;tn=baiduimagedetail&amp;is=0,0&amp;istype=0&amp;ie=utf-8&amp;oe=utf-8&amp;in=&amp;cl=2&amp;lm=-1&amp;st=undefined&amp;cs=875565228,81094927&amp;os=4129699680,2756185878&amp;simid=4075110645,549227620&amp;adpicid=0&amp;ln=1891&amp;fr=&amp;fmq=1481294094330_R&amp;fm=&amp;ic=undefined&amp;s=undefined&amp;se=&amp;sme=&amp;tab=0&amp;width=&amp;height=&amp;face=undefined&amp;ist=&amp;jit=&amp;cg=&amp;bdtype=0&amp;oriquery=&amp;objurl=http://wenwen.soso.com/p/20101027/20101027223540-1463998862.jpg&amp;fromurl=ippr_z2C%24qAzdH3FAzdH3Fojgojg_z&amp;e3Bf5f5_z&amp;e3Bv54AzdH3FzAzdH3Fqdn8ndll0a_z&amp;e3Bip4&amp;gsm=0&amp;rpstart=0&amp;rpnum=0\">图片出处</a> <br/>\n这就是一个平衡二叉树，因为它的所有叶都在2层与3层上。 <br/>\n同理一个满二叉树也是个平衡二叉树。</p>\n\n<p>在m叉树中叶数的界：常常用到m叉树中叶树的上界。定理5用m叉树的高度给出了一个这样的界。</p>\n\n<p>定理5.在高度为h的m叉树中最多有m^h个叶；</p>\n\n<p>推论1.若一颗高度为h的m叉树带有l个叶，则h &gt;= 向上取整logm(l)。若这棵树是满的和平衡的，则h = 向上取整logm(l)。</p>\n\n<p>参考资料： <br/>\n《离散数学及其应用(第七版)》</p>            </div>\n            <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/markdown_views-ea0013b516.css\"/>\n                ",
			"keywords":["discrete_math"]
		},
		{

			"title":"排列的问题 - CSDN博客",
			"content":"\n                    <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css\"/>\n            <div class=\"htmledit_views\">\n                \n<p>今天上离散数学，几道有意思的题整理了下。</p>\n<p>1.  5个0 ，6个1，排列有多少种</p>\n<p>     思路：不用去考虑1怎么排，想象现在有11个位置，在这11个位置里面选出5个填0就可以了，剩下的位置填1即可。所以答案就是11选5的排列，也可想到成</p>\n<p>     在     0 0 0 0 0 中插入6个1进行划分。 </p>\n<p> </p>\n<p>2.那现在有1元，2元，5元，10元，20元，50元，100元，每种钱币无限张，从中任意取5张，就总的取法</p>\n<p>   思路：可以把这道题进行转化，比如 11111100000 ，第一个1左边有没有0，代表1元的0张，第二个1和第一个1之间也没有0代表2元的0张，以此类推，第六个0与第五个0之间也没有0代表50元的0张，最右边还有5个0代表100元的有5张，假如现在是10100110110 ，第一个1左边没有0，代表1元的0张，第二个1与第一个1之间有1个0代表2元的1张，第三个1和第二个1之间有2个0代表5元的两张，第四个1和第三个1之间没有0代表10元的0张，第五个1和第四个1之间有1个0代表50元的1张，以此类推，这样有多少种选法又转化成了问题1\n ，6个1和5个0的全排列。</p>\n<p> </p>\n<p>那现在总结下吧，有n种物品，每种无限个，现在要选r个，总共的选法有 n+r-1选5 ，比如第二道题里面，有7种物品，每种无限个，选5个，答案是11选5，接下来再来做几个有意思的吧。</p>\n<p> </p>\n<p>3. x+y+z=21 ，其中x,y,z为非负整数，求有多少种</p>\n<p>   思路：现在就是可以想象成有21个0，   0 0 0 0 0 0.....0 0 0 0 ，用两个1去划分 ，比如 0 1 0 0 .... 0  0 1 0 ，第一个1左边0的个数代表x，第一个1和第二个1之间0的个数代表y，第二个1右边0的个数代表z，那现在就变成2个1和21个0的排列 ， 从23个位置中选出2个放1，剩余的地方放0，总共的放法有23选2种。</p>\n<p> </p>\n<p>4.那如果加上要求呢，x+y+z=21,其中x,y,z为非负整数，且x&gt;=11</p>\n<p>  思路：可以令x-11 = p ，问题就转化为 p+y+z=11  ， p,y,z为非负整数，有多少种放法，就可以用问题3的思路去解决</p>\n<p> </p>\n            </div>\n                ",
			"keywords":["discrete_math"]
		},
		{

			"title":"离散数学对编程究竟有用不？？？ - CSDN博客",
			"content":"\n                    <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css\"/>\n            <div class=\"htmledit_views\">\n                <p>上完了离散数学，到现在也还没有感觉到离散数学和编程有什么联系！学离散数学到底有用不？？有什么作用啊？？</p>            </div>\n                ",
			"keywords":["discrete_math"]
		},
		{

			"title":"C++中的得摩根定理 - CSDN博客",
			"content":"\n                    <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css\"/>\n            <div class=\"htmledit_views\">\n                \n<p>在数字逻辑和离散数学以及概率论中都学到了德摩根定理，没想到，还可以在C++中用到；</p>\n<p>在C++中逻辑表达式有时候很复杂，不容易理解，出了问题也很难检查。比如下面这个运算：</p>\n<p>!(x==a&amp;&amp;y!=b&amp;&amp;z!=c);</p>\n<p>需要简化逻辑表达式，需要用到德摩根定理，数学式为：</p>\n<p>-(A∧B)=(-A)∨(-B)</p>\n<p>-(A∨B)=(-A)∧(-B)</p>\n<p>用这个运算方法上式可以改为：</p>\n<p>（x!=a||y==b||z==c）;</p>\n<p><br/></p>\n            </div>\n                ",
			"keywords":["discrete_math"]
		},
		{

			"title":"谈谈如何学习离散数学 - CSDN博客",
			"content":"\n                    <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css\"/>\n            <div class=\"htmledit_views\">\n                \n<span style=\"color:#ffffff;\"><span style=\"font-family:arial;line-height:25px;background-color:rgb(18,58,107);\"/></span><span style=\"font-size:14px;\">  学习离散数学有两项最基本的任务：其一是通过学习离散数学，使学生了解和掌握在后续课程中要直接用到的一些数学概念和基本原理，掌握计算机中常用的科学论证方法，为后续课程的学习奠定一个良好的数学基础；其二是在离散数学的学习过程中，培训自学能力、抽象思维能力和逻辑推理能力，以提高专业理论水平。因此学习离散数学对于计算机、通信等专业后续课程的学习和今后从事计算机科学等工作是至关重要的。但是由于离散数学的离散性、知识的分散性和处理问题的特殊性，使部分学生在刚刚接触离散数学时，对其中的一些概念和处理问题的方法往往感到困惑，特别是在做证明题时感到无从下手，找不到正确的解题思路。因此，对离散数学的学习方法给予适当的指导和对学习过程中遇到的一些问题分析是十分必要的。<br/><br/><br/>\n一、认知离散数学<br/><br/><br/>\n离散数学是计算机科学基础理论的核心课程之一，是计算机及应用、通信等专业的一门重要的基础课。它以研究量的结构和相互关系为主要目标，其研究对象一般是有限个或可数个元素，充分体现了计算机科学离散性的特点。学习离散数学的目的是为学习计算机、通信等专业各后续课程做好必要的知识准备，进一步提高抽象思维和逻辑推理的能力，为计算机的应用提供必要的描述工具和理论基础。<br/><br/><br/>\n1．定义和定理多<br/><br/><br/>\n离散数学是建立在大量定义、定理之上的逻辑推理学科，因此对概念的理解是学习这门课程的核心。在学习这些概念的基础上，要特别注意概念之间的联系，而描述这些联系的实体则是大量的定理和性质。在考试中有一部分内容是考查学生对定义和定理的识记、理解和运用，因此要真正理解离散数学中所给出的每个基本概念的真正的含义。比如，命题的定义、五个基本联结词、公式的主析取范式和主合取范式、三个推理规则以及反证法；集合的五种运算的定义；关系的定义和关系的四个性质；函数（映射）和几种特殊函数（映射）的定义；图、完全图、简单图、子图、补图的定义；图中简单路、基本路的定义以及两个图同构的定义；树与最小生成树的定义。掌握和理解这些概念对于学好离散数学是至关重要的。<br/><br/><br/>\n2. 方法性强<br/><br/><br/>\n在离散数学的学习过程中，一定要注重和掌握离散数学处理问题的方法，在做题时，找到一个合适的解题思路和方法是极为重要的。如果知道了一道题用怎样的方法去做或证明，就能很容易地做或证出来。反之，则事倍功半。在离散数学中，虽然各种各样的题种类繁多，但每类题的解法均有规律可循。所以在听课和平时的复习中，要善于总结和归纳具有规律性的内容。在平时的讲课和复习中，老师会总结各类解题思路和方法。作为学生，首先应该熟悉并且会用这些方法，同时，还要勤于思考，对于一道题，进可能地多探讨几种解法。<br/><br/><br/>\n3. 抽象性强<br/><br/><br/>\n离散数学的特点是知识点集中，对抽象思维能力的要求较高。由于这些定义的抽象性，使初学者往往不能在脑海中直接建立起它们与现实世界中客观事物的联系。不管是哪本离散数学教材，都会在每一章中首先列出若干个定义和定理，接着就是这些定义和定理的直接应用，如果没有较好的抽象思维能力，学习离散数学确实具有一定的困难。因此，在离散数学的学习中，要注重抽象思维能力、逻辑推理能力的培养和训练，这种能力的培养对今后从事各种工作都是极其重要的。<br/><br/><br/>\n在学习离散数学中所遇到的这些困难，可以通过多学、多看、认真分析讲课中所给出的典型例题的解题过程，再加上多练，从而逐步得到解决。在此特别强调一点：深入地理解和掌握离散数学的基本概念、基本定理和结论，是学好离散数学的重要前提之一。所以，同学们要准确、全面、完整地记忆和理解所有这些基本定义和定理。<br/><br/><br/>\n4. 内在联系性<br/><br/><br/>\n离散数学的三大体系虽然来自于不同的学科，但是这三大体系前后贯通，形成一个有机的整体。通过认真的分析可寻找出三大部分之间知识的内在联系性和规律性。如：集合论、函数、关系和图论，其解题思路和证明方法均有相同或相似之处。<br/><br/><br/>\n二、认知解题规范<br/><br/><br/>\n一般来说，离散数学的考试要求分为：了解、理解和掌握。了解是能正确判别有关概念和方法；理解是能正确表达有关概念和方法的含义；掌握是在理解的基础上加以灵活应用。为了考核学生对这三部分的理解和掌握的程度，试题类型一般可分为：判断题、填空题、选择题、计算题和证明题。判断题、填空题、选择题主要涉及基本概念、基本理论、重要性质和结论、公式及其简单计算；计算题主要考核学生的基本运用技能和速度，要求写出完整的计算过程和步骤；证明题主要考查应用概念、性质、定理及重要结论进行逻辑推理的能力，要求写出严格的推理和论证过程。<br/><br/><br/>\n学习离散数学的最大困难是它的抽象性和逻辑推理的严密性。在离散数学中，假设让你解一道题或证明一个命题，你应首先读懂题意，然后寻找解题或证明的思路和方法，当你相信已找到了解题或证明的思路和方法，你必须把它严格地写出来。一个写得很好的解题过程或证明是一系列的陈述，其中每一条陈述都是前面的陈述经过简单的推理而得到的。仔细地写解题过程或证明是很重要的，既能让读者理解它，又能保证解题过程或证明准确无误。一个好的解题过程或证明应该是条理清楚、论据充分、表述简洁的。针对这一要求，在讲课中老师会提供大量的典型例题供同学们参考和学习。<br/><br/><br/>\n通过离散数学的学习和训练，能使同学们学会在离散数学中处理问题的一般性的规律和方法，一旦掌握了离散数学中这种处理问题的思想方法，学习和掌握离散数学的知识就不再是一件难事了。<br/><br/><br/>\n//我上课睡觉是没办法的啊，老师讲课太无聊了。。。</span>\n<p><span style=\"font-family:arial;\"><span style=\"font-size:14px;line-height:25px;\"><span style=\"color:#ffffff;\"/></span></span></p>\n            </div>\n                ",
			"keywords":["discrete_math"]
		},
		{

			"title":"如何学习离散数学和在计算机科学中应用 - CSDN博客",
			"content":"\n                    <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css\"/>\n            <div class=\"htmledit_views\">\n                <h3><span style=\"font-family:'Comic Sans MS';\">引言</span></h3><p><span style=\"font-family:'Comic Sans MS';\">离散数学的定义及其在各学科领域的重要作用。离散数学(Discrete mathematics)是研究离散量的结构及其相互关系的数学学科，是现代数学的一个重要分支。它在各学科领域，特别在计算机科学与技术领域有着广泛的应用，同时离散数学也是计算机专业的许多专业课程，如<span style=\"color:#FF0000;\">程序设计语言、数据结构、操作系统、编译技术、人工智能、数据库、算法设计与分析、理论计算机科学基础等必不可少的先行课程</span>。通过离散数学的学习，不但可以<span style=\"color:#FF0000;\">掌握处理离散结构的描述工具和方法</span>，为后续课程的学习创造条件，而且可以提高抽象思维和严格的逻辑推理能力，为将来参与创新性的研究和开发工作打下坚实的基础。</span></p><p><span style=\"font-family:'Comic Sans MS';\">随着信息时代的到来，工业革命时代以微积分为代表的连续数学占主流的地位已经发生了变化，离散数学的重要性逐渐被人们认识。离散数学课程所传授的思想和方法，广泛地体现在计算机科学技术及相关专业的诸领域，从科学计算到信息处理，从理论计算机科学到计算机应用技术，从计算机软件到计算机硬件，从人工智能到认知系统，无不与离散数学密切相关。</span></p><p><span style=\"font-family:'Comic Sans MS';\">由于数字电子计算机是一个离散结构，它只能处理离散的或离散化了的数量关系， 因此，无论计算机科学本身，还是与计算机科学及其应用密切相关的现代科学研究领域，都面临着如何对离散结构建立相应的数学模型；又如何将已用连续数量关系建立起来的数学模型离散化，从而可由计算机加以处理。由此可见，离散数学在计算机科学中具有广泛的应用.</span><span class=\"tcnt\"><br/></span></p><h3><span class=\"tcnt\">如何学习离散数学</span>  <br/></h3><p><span style=\"font-family:'Comic Sans MS';\">学习离散数学有两项最基本的任务：其一是通过学习离散数学，使学生了解和掌握在后续课程中要直接用到的一些数学概念和基本原理，掌握计算机中常用的科学论证方法，为后续课程的学习奠定一个良好的数学基础；其二是在离散数学的学习过程中，培训自学能力、抽象思维能力和逻辑推理能力，以提高专业理论水平。因此学习离散数学对于计算机、通信等专业后续课程的学习和今后从事计算机科学等工作是至关重要的。但是由于离散数学的离散性、知识的分散性和处理问题的特殊性，使部分学生在刚刚接触离散数学时，对其中的一些概念和处理问题的方法往往感到困惑，特别是在做证明题时感到无从下手，找不到正确的解题思路。因此，对离散数学的学习方法给予适当的指导和对学习过程中遇到的一些问题分析是十分必要的。</span></p><h4><span style=\"font-family:'Comic Sans MS';\">认知离散数学</span></h4><p><span style=\"font-family:'Comic Sans MS';\">离散数学是计算机科学基础理论的核心课程之一，是计算机及应用、通信等专业的一门重要的基础课。它以研究量的结构和相互关系为主要目标，其研究对象一般是有限个或可数个元素，充分体现了计算机科学离散性的特点。学习离散数学的目的是为学习计算机、通信等专业各后续课程做好必要的知识准备，进一步提高抽象思维和逻辑推理的能力，为计算机的应用提供必要的描述工具和理论基础。</span><span style=\"font-family:'Comic Sans MS';\"><br/></span></p><ul><li><span style=\"font-family:'Comic Sans MS';\"><strong>定义和定理多</strong> 离散数学是建立在大量定义、定理之上的逻辑推理学科，因此对概念的理解是学习这门课程的核心。在学习这些概念的基础上，要特别注意概念之间的联系，而描述这些联系的实体则是大量的定理和性质。在考试中有一部分内容是考查学生对定义和定理的识记、理解和运用，因此要真正理解离散数学中所给出的每个基本概念的真正的含义。比如，命题的定义、五个基本联结词、公式的主析取范式和主合取范式、三个推理规则以及反证法；集合的五种运算的定义；关系的定义和关系的四个性质；函数（映射）和几种特殊函数（映射）的定义；图、完全图、简单图、子图、补图的定义；图中简单路、基本路的定义以及两个图同构的定义；树与最小生成树的定义。掌握和理解这些概念对于学好离散数学是至关重要的。</span></li><li><strong><span style=\"font-family:'Comic Sans MS';\">方法性强</span></strong><span style=\"font-family:'Comic Sans MS';\"> 在离散数学的学习过程中，一定要注重和掌握离散数学处理问题的方法，在做题时，找到一个合适的解题思路和方法是极为重要的。如果知道了一道题用怎样的方法去做或证明，就能很容易地做或证出来。反之，则事倍功半。在离散数学中，虽然各种各样的题种类繁多，但每类题的解法均有规律可循。所以在听课和平时的复习中，要善于总结和归纳具有规律性的内容。在平时的讲课和复习中，老师会总结各类解题思路和方法。作为学生，首先应该熟悉并且会用这些方法，同时，还要勤于思考，对于一道题，进可能地多探讨几种解法。</span></li><li><strong><span style=\"font-family:'Comic Sans MS';\">抽象性强</span></strong><span style=\"font-family:'Comic Sans MS';\"> 离散数学的特点是知识点集中，对抽象思维能力的要求较高。由于这些定义的抽象性，使初学者往往不能在脑海中直接建立起它们与现实世界中客观事物的联系。不管是哪本离散数学教材，都会在每一章中首先列出若干个定义和定理，接着就是这些定义和定理的直接应用，如果没有较好的抽象思维能力，学习离散数学确实具有一定的困难。因此，在离散数学的学习中，要注重抽象思维能力、逻辑推理能力的培养和训练，这种能力的培养对今后从事各种工作都是极其重要的。</span><span style=\"font-family:'Comic Sans MS';\">在学习离散数学中所遇到的这些困难，可以通过多学、多看、认真分析讲课中所给出的典型例题的解题过程，再加上多练，从而逐步得到解决。在此特别强调一点：深入地理解和掌握离散数学的基本概念、基本定理和结论，是学好离散数学的重要前提之一。所以，同学们要准确、全面、完整地记忆和理解所有这些基本定义和定理。</span></li><li><strong>内在联系性</strong><span style=\"font-family:'Comic Sans MS';\"> </span>离散数学的三大体系虽然来自于不同的学科，但是这三大体系前后贯通，形成一个有机的整体。通过认真的分析可寻找出三大部分之间知识的内在联系性和规律性。如：集合论、函数、关系和图论，其解题思路和证明方法均有相同或相似之处。</li></ul><h4>认知解题规范</h4><p>一般来说，离散数学的考试要求分为：了解、理解和掌握。了解是能正确判别有关概念和方法；理解是能正确表达有关概念和方法的含义；掌握是在理解的基础上加以灵活应用。为了考核学生对这三部分的理解和掌握的程度，试题类型一般可分为：判断题、填空题、选择题、计算题和证明题。判断题、填空题、选择题主要涉及基本概念、基本理论、重要性质和结论、公式及其简单计算；计算题主要考核学生的基本运用技能和速度，要求写出完整的计算过程和步骤；证明题主要考查应用概念、性质、定理及重要结论进行逻辑推理的能力，要求写出严格的推理和论证过程。<span style=\"font-family:'Comic Sans MS';\"><br/></span></p><p><span style=\"font-family:'Comic Sans MS';\">学习离散数学的最大困难是它的抽象性和逻辑推理的严密性。在离散数学中，假设让你解一道题或证明一个命题，你应首先读懂题意，然后寻找解题或证明的思路和方法，当你相信已找到了解题或证明的思路和方法，你必须把它严格地写出来。一个写得很好的解题过程或证明是一系列的陈述，其中每一条陈述都是前面的陈述经过简单的推理而得到的。仔细地写解题过程或证明是很重要的，既能让读者理解它，又能保证解题过程或证明准确无误。一个好的解题过程或证明应该是条理清楚、论据充分、表述简洁的。针对这一要求，在讲课中老师会提供大量的典型例题供同学们参考和学习。</span></p><p><span style=\"font-family:'Comic Sans MS';\">通过离散数学的学习和训练，能使同学们学会在离散数学中处理问题的一般性的规律和方法，一旦掌握了离散数学中这种处理问题的思想方法，学习和掌握离散数学的知识就不再是一件难事了。</span><br/></p><h4>学习离散数学的目的</h4><p>一般来说，离散数学内容广泛且高度抽象，可以说是一门既难教又难学的课程，这无疑给教师的教学和学生的学习带来了一定的难度。一方面，离散数学不仅 是为专业服务的基本理论，而且通过该课程可以培养学生的抽象思维和缜密概括的能力，但其概念多，理论性强，高度抽象性的特点却令许多学生望而生畏。学生在 学习这门课程时，往往看不到离散数学在计算机科学中的具体应用，因而放松对离散数学的学习，失去学习的兴趣。</p><p/><p><span style=\"font-family:'Comic Sans MS';\"/></p><p>离散数学的生命力在于其深刻的理论和广泛的应用。其实，深刻的理论和广泛的应用是相辅相成的。学生之所以对离散数学的学习兴趣不高，除了离散数学本身理论性 强、比较抽象以外，还有一个原因就是对于这些理论方面的知识，学生在学习过程中并不会切实地感受到学好它的作用和成效，因此只把应付考试作为学习这门课程 的目的。作为老师，我们在教学之初就应该向学生们指明，<span style=\"color:#FF0000;\"><strong>学习离散数学的目的</strong>在于培养学生的抽象推理、逻辑思维和归纳构造等能力，提高学生利用数学方法解决问题的技能，以及为后续课程作必要的准备，为学生的进一步学习奠定计算机数学的基础。它所涉及的概念、方法和理论，大量地应用在数字电路、编译原理、数据结构、操作系统、数据库、算法等领域。</span><strong><br/></strong></p><h3><span style=\"font-family:'Comic Sans MS';\"/></h3><p><span style=\"font-family:'Comic Sans MS';\">离散数学在计算机科学</span>应用</p><h4><span style=\"font-family:'Comic Sans MS';\"/></h4><p align=\"left\"><span style=\"font-family:'Comic Sans MS';\">在人工智能中的应用 <br/></span></p><p><span style=\"font-family:'Comic Sans MS';\"/></p><p align=\"left\"><span style=\"font-family:'Comic Sans MS';\">人工智能是计算机学科中一个非常重要的方向,离散数学在人工智能中的应用主要是数理逻辑部分在人工智能中的应用。<span style=\"color:#FF0000;\">数理逻辑包括命题逻辑和谓词逻辑,命题逻辑就是研究以命题为单位进行前提与结论之间的推理,而谓词逻辑就是研究句子内在的联系。</span>大家都知道,人工智能共有两个流派,连接主义流派和符号主义流派。其中在符号主义流派里,他们认为现实世界的各种事物可以用符号的形式表示出来,其中最主要的就是人类的自然语言可以用符号进行表示。语言的符号化就是数理逻辑研究的基本内容,计算机智能化的前提就是将人类的语言符号化成机器可以识别的符号,这样计算机才能进行推理,才能具有智能。由此可见数理逻辑中重要的思想、方法及内容贯穿到人工智能的整个学科。 </span></p><p align=\"left\"><span style=\"font-family:'Comic Sans MS';\">在人工智能的研究与应用领域中，逻辑推理是人工智能研究中最持久的子领域之一。逻辑是所有数学推理的基础，对人工智能有实际的应用。采用谓词逻辑语言的演绎过程的形式化有助于我们更清楚地理解推理的某些子命题。逻辑规则给出数学语句的准确定义。离散数学中数学推理和布尔代数章节中的知识就为早期的人工智能研究领域打下了良好的数学基础。许多非形式的工作，包括医疗诊断和信息检索都可以和定理证明问题一样加以形式化。因此，在人工智能方法的研究中定理证明是一个极其重要的论题。在这里，推理机就是实现(机器)推理的程序。它既包括通常的逻辑推理，也包括基于产生式的操作。推理机是使用知识库中的知识进行推理而解决问题的。所以推理机也就是专家的思维机制，即专家分析问题、解决问题的方法的一种算法表示和机器实现。</span></p><h4><span style=\"font-family:'Comic Sans MS';\">在数据库系统理论中的应用 <br/></span></h4><p align=\"left\"><span style=\"font-family:'Comic Sans MS';\">集合论是离散数学中极其重要的一部分,它在数据库中有着广泛的应用。我们可以利用关系理论使数据库从网络型、层次型转变成关系型,这样使数据库中的数据容易表示,并且易于存储和处理,使逻辑结构简单、数据独立性强、数据共享、数据冗余可控和操作简单。当数据库中记录较多时,集合中的笛卡儿积方便了记录的查询、插入、删除和修改。 关系数据库中的数据管理系统向用户提供使用的数据库语言称为数据子语言，它是以关系代数或谓词逻辑中的方法表示。由于用这种数学的方法去表示，使得对这些语言的研究成为对关系代数或逻辑谓词的研究，优化语言的表示变成为对关系代数与谓词逻辑的化简问题。由于引入了数学表示方法，使得关系数据库具有比其它几种数据库较为优越的条件。正因为如此关系数据库迅速发展成为一种很有前途、很有希望的数据库。另外，离散数学中的笛卡儿积是一个纯数学理论，是研究关系数据库的一种重要方法，显示出不可替代的作用。不仅为其提供理论和方法上的支持，更重要的是推动了数据库技术的研究和发展。关系数据模型建立在严格的集合代数的基础上，其数据的逻辑结构是一个由行和列组成的二维表来描述关系数据模型。在研究实体集中的域和域之间的可能关系、表结构的确定与设计、关系操作的数据查询和维护功能的实现、关系分解的无损连接性分析、连接依赖等问题都用到二元关系理论。</span></p><h4 align=\"left\"><span style=\"font-family:'Comic Sans MS';\"><strong>在数据结构中的应用</strong></span></h4><p align=\"left\"><span style=\"font-family:'Comic Sans MS';\">计算机要解决一个具体问题，必须运用数据结构知识。对于问题中所处理的数据，必须首先从具体问题中抽象出一个适当的数学模型，然后设计一个解此数学模型的算法，最后编出程序，进行测试、调整直至得到问题的最终解答。而寻求数学模型就是数据结构研究的内容。寻求数学模型���实质是分析问题，从中提取操作的对象，并找出这些操作对象之间含有的关系，然后用数学的语言加以描述。数据结构中将操作对象间的关系分为四类：集合、线性结构、树形结构、图状结构或网状结构。数据结构研究的主要内容是数据的逻辑结构，物理存储结构以及基本运算操作。其中逻辑结构和基本运算操作来源于离散数学中的离散结构和算法思考。离散数学中的集合论、关系、图论、树四个章节就反映了数据结构中四大结构的知识。如集合由元素组成，元素可理解为世上的客观事物。关系是集合的元素之间都存在某种关系。例如雇员与其工资之间的关系。图论是有许多现代应用的古老题目。伟大的瑞士数学家列昂哈德·欧拉在18 世纪引进了图论的基本思想，他利用图解决了有名的哥尼斯堡七桥问题。还可以用边上带权值的图来解决诸如寻找交通网络里两城市之间最短通路的问题。而树反映对象之间的关系，如组织机构图、家族图、二进制编码都是以树作为模型来讨论。</span></p><h4 align=\"left\"><span style=\"font-family:'Comic Sans MS';\"><strong>在编译原理中的应用</strong></span></h4><p align=\"left\"><span style=\"font-family:'Comic Sans MS';\">编译程序是计算机的一个十分复杂的系统程序。一个典型的编译程序一般都含有八个部分：词法分析程序、语法分析程序、语义分析程序、中间代码生成程序、代码优化程序、目标代码生成程序、错误检查和处理程序、各种信息表格的管理程序。离散数学里的计算模型章节里就讲了三种类型的计算模型：文法、有限状态机和图灵机。具体知识有语言和文法、带输出的有限状态机、不带输出的有限状态机、语言的识别、图灵机等。短语结构文法根据产生式类型来分类：0 型文法、1 型文法、2 型文法、3 型文法。以上这些在离散数学里讲述到的知识点在编译原理的词法分析及语法分析中都会用到。因此，离散数学也是编译原理的前期基础课程。<br/></span></p><h4 align=\"left\"><span style=\"font-family:'Comic Sans MS';\">在计算机硬件设计中的应用</span></h4><p align=\"left\"><span style=\"font-family:'Comic Sans MS';\">数字逻辑作为计算机的一个重要理论，在很大程度上起源于离散数学的数理逻辑中的命题与逻辑演算，其在计算机硬件设计中的应用更为突出。利用命题中各关联词的运算规律把又电平表示的各信号之间的运算于二进制数之间的运算联系起来，使得我们可以用与非门或者用或非门来解决电路设计问题，使得整个设计过程更加直观、系统化。数理逻辑在程序设计中起到花间的作用，当一个程序初稿拿出来以后，如果我们想分析一下其中是否有冗余存在，这时就用到了离散数学中命题演算的基本等式。<strong><br/></strong></span></p><h4 align=\"left\"><span style=\"font-family:'Comic Sans MS';\"><strong> 在计算机纠错码中的应用</strong></span></h4><p align=\"left\"><span style=\"font-family:'Comic Sans MS';\">计算机中，常常需要将二进制数字信号进行传递。这种传递的距离近则数米、数毫米，远则超过数千公里。在传递过程中，由于存在各种干挠，常常会使二进制信号产生失真现象。而利用离散数学的集合论、群论和数理逻辑来分析研究计算机纠错码的纠错能力，是离散数学在计算机科学中的一个重要应用方面。代数系统在计算机中的应用广泛,例如有限机,开关线路的计数等方面。但最常用的是在纠错码方面的应用。在计算机和数据通信中,经常需要将二进制数字信号进行传递,这种传递常常距离很远,所以难免会出现错误。通常采用纠错码来避免这种错误的发生,而设计的这种纠错码的数学基础就是代数系统。纠错码中的一致校验矩阵就是根据代数系统中的群概念来进行设计的,另外在群码的校正中,也用到了代数系统中的陪集。 </span><br/></p><h4 align=\"left\">在生物信息学中的应用 <br/></h4><p align=\"left\"><span style=\"font-family:'Comic Sans MS';\">生物信息学是现代计算机科学中一个崭新的分支,它是计算机科学与生物学相结合的产物。目前,在美国有一个国家实验室Sandia国家实验室,主要进行组合编码理论和密码学的研究,该机构在美国和国际学术界有很高的地位。另外,由于DNA是离散数学中的序列结构,美国科学院院士,近代离散数学的奠基人Rota教授预言,生物学中的组合问题将成为离散数学的一个前沿领域。而且,IBM公司也将成立一个生物信息学研究中心。在1994年美国计算机科学家阿德勒曼公布了DNA计算机的理论,并成功地运用DNA计算机解决了一个有向哈密尔顿路径问题,这一成果迅速在国际产生了巨大的反响,同时也引起了国内学者的关注。DNA计算机的基本思想是:以DNA碱基序列作为信息编码的载体,利用现代分子生物学技术,在试管内控制酶作用下的DNA序列反应,作为实现运算的过程;这样,以反应前DNA序列作为输入的数据,反应后的DNA序列作为运算的结果,DNA计算机几乎能够解决所有的NP完全问题。</span> </p><h4 align=\"left\"><strong>在其他方面的应用</strong></h4><p align=\"left\"><strong> </strong><span style=\"font-family:'Comic Sans MS';\">对谓词演算公理系统的研究使得美国数理逻辑学家罗宾逊于1965 年创立了“消解原理”的算法,在此算法的基础上,法国马赛大学的柯尔密勒设计并实现了一种基于谓词演算的逻辑程序设计语言PROLOG(programming in logic) ,该语言不久即在众多计算机上得以实现. 这样一来,现实世界中的问题只要能用谓词演算公理系统方式表示出来,就可以将它写成PROLOG程序,然后在计算机上得以实现。</span></p><p align=\"left\"><span style=\"font-family:'Comic Sans MS';\"><br/></span></p><h3 align=\"left\"><strong>参考文献</strong></h3><p><span style=\"font-family:'Comic Sans MS';\">[1] <a href=\"http://en.wikipedia.org/wiki/Discrete_mathematics\">Discrete mathematics</a> From Wikipedia, the free encyclopedia</span></p><p><span style=\"font-family:'Comic Sans MS';\">[2]<span class=\"external text\"> </span><a class=\"external text\" href=\"http://archives.math.utk.edu/topics/discreteMath.html\">Discrete mathematics</a> at the utk.edu Mathematics Archives, providiing links to syllabi, tutorials, programs, etc.<br/></span></p><p><span style=\"font-family:'Comic Sans MS';\"><span class=\"reference-text\">[3] </span><span class=\"reference-text\"><span class=\"citation mathworld\" id=\"Reference-Mathworld-Discrete_mathematics\"><a href=\"http://en.wikipedia.org/wiki/Eric_W._Weisstein\" title=\"Eric W. Weisstein\">Weisstein, Eric W.</a>, <a class=\"external text\" href=\"http://mathworld.wolfram.com/DiscreteMathematics.html\">\"Discrete mathematics\"</a>, <em><a href=\"http://en.wikipedia.org/wiki/MathWorld\" title=\"MathWorld\">MathWorld</a></em>.</span></span><br/></span> <span style=\"font-family:'Comic Sans MS';\"><span class=\"reference-text\"><span id=\"CITEREFBiggs2002\" class=\"citation\">[4]  <a href=\"http://en.wikipedia.org/wiki/Norman_L._Biggs\" title=\"Norman L. Biggs\">Biggs, Norman L.</a> (2002), <a class=\"external text\" href=\"http://books.google.com/books?id=Mj9gzZMrXDIC&amp;pg=PA89\"><em>Discrete mathematics</em></a>, Oxford Science Publications (2nd ed.), New York: The Clarendon Press Oxford University Press, p. 89, <a href=\"http://en.wikipedia.org/wiki/International_Standard_Book_Number\" title=\"International Standard Book Number\">ISBN</a> <a href=\"http://en.wikipedia.org/wiki/Special:BookSources/9780198507178\" title=\"Special:BookSources/9780198507178\">9780198507178</a>, <a href=\"http://en.wikipedia.org/wiki/Mathematical_Reviews\" title=\"Mathematical Reviews\">MR</a> <a class=\"external text\" href=\"http://www.ams.org/mathscinet-getitem?mr=1078626\">1078626</a>, <q>Discrete Mathematics is the branch of Mathematics in which we deal with questions involving finite or countably infinite sets.</q></span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ADiscrete+mathematics&amp;rft.au=Biggs%2C+Norman+L.&amp;rft.aufirst=Norman+L.&amp;rft.aulast=Biggs&amp;rft.btitle=Discrete+mathematics&amp;rft.date=2002&amp;rft.edition=2nd&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DMj9gzZMrXDIC%26pg%3DPA89&amp;rft.isbn=9780198507178&amp;rft.mr=1078626&amp;rft.pages=89&amp;rft.place=New+York&amp;rft.pub=The+Clarendon+Press+Oxford+University+Press&amp;rft.series=Oxford+Science+Publications&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook\" class=\"Z3988\"/></span></span><span style=\"font-family:'Comic Sans MS';\"><span class=\"reference-text\"/><span class=\"reference-text\"><span class=\"citation book\"><br/></span></span></span></p><p><span style=\"font-family:'Comic Sans MS';\"><span class=\"reference-text\"><span class=\"citation book\">[5] <a href=\"http://en.wikipedia.org/wiki/Robin_Wilson_%28mathematician%29\" title=\"Robin Wilson (mathematician)\">Wilson, Robin</a> (2002). <em>Four Colors Suffice</em>. London: Penguin Books. <a href=\"http://en.wikipedia.org/wiki/International_Standard_Book_Number\" title=\"International Standard Book Number\">ISBN</a> <a href=\"http://en.wikipedia.org/wiki/Special:BookSources/978-0-691-11533-7\" title=\"Special:BookSources/978-0-691-11533-7\">978-0-691-11533-7</a>.</span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ADiscrete+mathematics&amp;rft.aufirst=Robin&amp;rft.aulast=Wilson&amp;rft.au=Wilson%2C+Robin&amp;rft.btitle=Four+Colors+Suffice&amp;rft.date=2002&amp;rft.genre=book&amp;rft.isbn=978-0-691-11533-7&amp;rft.place=London&amp;rft.pub=Penguin+Books&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook\" class=\"Z3988\"/></span><span class=\"reference-text\"><span class=\"citation book\"><br/></span></span></span></p><p><span style=\"font-family:'Comic Sans MS';\"><span class=\"reference-text\"><span class=\"citation book\">[6]</span></span> <span class=\"reference-text\"><span class=\"citation book\">Samuel R. Buss (1998). <a class=\"external text\" href=\"http://books.google.com/?id=MfTMDeCq7ukC&amp;pg=PA13\"><em>Handbook of Proof Theory</em></a>. Elsevier. p. 13. <a href=\"http://en.wikipedia.org/wiki/International_Standard_Book_Number\" title=\"International Standard Book Number\">ISBN</a> <a href=\"http://en.wikipedia.org/wiki/Special:BookSources/978-0-444-89840-1\" title=\"Special:BookSources/978-0-444-89840-1\">978-0-444-89840-1</a>.</span><span title=\"ctx_ver=Z39.88-2004&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3ADiscrete+mathematics&amp;rft.aulast=Samuel+R.+Buss&amp;rft.au=Samuel+R.+Buss&amp;rft.btitle=Handbook+of+Proof+Theory&amp;rft.date=1998&amp;rft.genre=book&amp;rft_id=http%3A%2F%2Fbooks.google.com%2F%3Fid%3DMfTMDeCq7ukC%26pg%3DPA13&amp;rft.isbn=978-0-444-89840-1&amp;rft.pages=13&amp;rft.pub=Elsevier&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook\" class=\"Z3988\"/></span><span class=\"reference-text\"><span class=\"citation book\"><br/></span></span></span></p><p><span style=\"font-family:'Comic Sans MS';\"><span class=\"reference-text\"><span class=\"citation book\">[7] </span></span>耿素云,屈婉玲,离散数学[M].北京:高等教育出版社,1998. <br/></span></p><p><span style=\"font-family:'Comic Sans MS';\">[8] 左孝凌,李永监,刘永才编著.离散数学[M].上海:上海科学技术文献出版社,2004. </span></p><p><span style=\"font-family:'Comic Sans MS';\">[9] 朱一清.离散数学[M].北京:电子工业出版社,2004</span></p><p><br/></p><p align=\"center\"><span style=\"font-family:'Comic Sans MS';\"><span style=\"font-family:'Comic Sans MS';\"><span style=\"color:#33CC00;\"><span style=\"background-color:rgb(255,255,255);\"><span style=\"font-family:'Comic Sans MS';\">关于<a href=\"http://blog.csdn.net/songzitea/article/category/2900415\">Discrete Mathematics</a>更多讨论与交流，敬请关注本博客和新浪微博<a href=\"http://weibo.com/songzitea\">songzi_tea</a>.</span></span></span></span></span><br/></p>            </div>\n                ",
			"keywords":["discrete_math"]
		},
		{

			"title":"学习离散数学的目的 - CSDN博客",
			"content":"\n                    <link rel=\"stylesheet\" href=\"https://csdnimg.cn/release/phoenix/template/css/htmledit_views-0a60691e80.css\"/>\n            <div class=\"htmledit_views\">\n                <p align=\"center\"/><h1>学习离散数学的目的</h1><p><br/></p><p/><h2>离散数学绝缘何难学？</h2><br/><p>摘自《提高离散数学教学质量的思考与实践》<br/>一般来说，离散数学内容广泛且高度抽象，可以说是一门既难教又难学的课程，这无疑给教师的教学和学生的学习带来了一定的难度。一方面，离散数学不仅是为专业服务的基本理论，而且通过该课程可以培养学生的抽象思维和缜密概括的能力，但其概念多，理论性强，高度抽象性的特点却令许多学生望而生畏。学生在学习这门课程时，往往看不到离散数学在计算机科学中的具体应用，因而放松对离散数学的学习，失去学习的兴趣。<br/><br/>1. 使学生认识到学好离散数学的重要性 <br/>离散数学的生命力在于其深刻的理论和广泛的应用。其实，深刻的理论和广泛的应用是相辅相成的。学生之所以对离散数学的学习兴趣不高，除了离散数学本身理论性强、比较抽象以外，还有一个原因就是对于这些理论方面的知识，学生在学习过程中并不会切实地感受到学好它的作用和成效，因此只把应付考试作为学习这门课程的目的。作为老师，我们在教学之初就应该向学生们指明，<font color=\"#000000\"><b>学习离散数学的目的</b></font>在于培养学生的抽象推理、逻辑思维和归纳构造等能力，提高学生利用数学方法解决问题的技能，以及为后续课程作必要的准备，为学生的进一步学习奠定计算机数学的基础。它所涉及的概念、方法和理论，大量地应用在数字电路、编译原理、数据结构、操作系统、数据库、算法等领域。</p>\n<p><br/><br/></p>\n<p/><h2>Objectives目标</h2><p><a href=\"http://www.core.org.cn/OcwWeb/Electrical-Engineering-and-Computer-Science/6-042JFall-2005/Syllabus/index.htm#Course_Objectives_and_Outcomes\">http://www.core.org.cn/OcwWeb/Electrical-Engineering-and-Computer-Science/6-042JFall-2005/Syllabus/index.htm#Course_Objectives_and_Outcomes</a></p>\n<p>On completion of 6.042, students will be able to explain and apply the basic methods of discrete (noncontinuous) mathematics in Computer Science. They will be able to use these methods in subsequent courses in the design and analysis of algorithms, computability theory, software engineering, and computer systems.<br/>完成本课程后，学生将能够解释离散数学的基本方法，并将这些方法应用到计算科学中去，如算法设计和分析、可计算理论、软件工程和计算机系统。<br/><br/></p>\n<p>In particular, students will be able to:<br/>特别地，学生将能够：<br/>  1.  Reason mathematically about basic data types and structures (such as numbers, sets, graphs, and trees) used in computer algorithms and systems; distinguish rigorous严格 definitions and conclusions from merely plausible貌似真实的 ones; synthesize elementary proofs, especially proofs by induction. <br/>（在使用计算机解决问题的时候）更能数学地对③在计算机算法及系统中使用基本数据类型和结构（如数字、集合、图和树）进行思考和推理；能严格地区分似是而非的定义和结论；能进行初等数学论证，尤其是归纳证明。<br/>  2.  Model and analyze computational processes using analytic and combinatorial methods. <br/>能使用分析和组合的方法对“计算过程”进行建模和分析。<br/>  3.  Apply principles of discrete probability to calculate probabilities and expectations预料 of simple random processes. <br/>能对简单的随机过程的机率预测（可靠性问题）和概率计算（估计问题）应用离散机率原理；<br/>  4.  Work in small teams to accomplish all the objectives above.<br/>能通过以小组协作的形式来完成以上的目标。</p><p><br/></p>\n<p/><h2>Learning Outcomes学习结果</h2><p>Students will be able to:<br/>学生将能够：<br/>  1.  Use logical notation to define and reason about fundamental mathematical concepts such as sets, relations, functions, and integers. <br/>   1.使用逻辑符号来定义与厘清基础数学概念，例如集合、关系式、函数和整数。<br/>  2.  Evaluate elementary mathematical arguments and identify fallacious谬误的 reasoning (not just fallacious conclusions). <br/>   2.评判基础的数学论述，明辩谬误的推理(不仅仅是谬误的结论)。<br/>  3.  Synthesize induction hypotheses and simple induction proofs. <br/>   3.作出归纳法假设，进行简单的归纳法证明。<br/>  4.  Prove elementary properties of modular arithmetic and explain their applications in Computer Science, for example, in cryptography and hashing algorithms. <br/>验证“模算术”（一种整数的算术系统）的基本性质和解释它在计算机科学中的应用，如在密码学和散列算法。<br/>  5.  Apply graph theory models of data structures and state machines to solve problems of connectivity and constraint satisfaction, for example, scheduling. <br/>   5.应用数据结构中的图论模型和状态机来解决连通性(connectivity)和约束满足问题(constraint satisfaction)问题，比如（任务）调度问题。<br/>  6.  Apply the method of invariants and well-founded ordering to prove correctness and termination of processes and state machines. <br/>   6.应用不变式与良基序式(well-founded ordering)以证明状态机与过程(Process)的正确和终结。<br/>  7.  Derive closed-form and asymptotic expressions from series and recurrences for growth rates of processes. <br/>   7.利用级数和递推式，为程序成长率导出封闭型态与渐近表达式。<br/>  8.  Calculate numbers of possible outcomes of elementary combinatorial processes such as permutations排列 and combinations. <br/>   8.计算出基本组合程序（例如排列与组合）的可能产生数目。<br/>  9.  Calculate probabilities and discrete distributions for simple combinatorial processes; calculate expectations. <br/>   8.为简单的组合程序计算机率和离散型分布、计算平均值和变异数<br/>   9.透过将理论应用于离均差（观察值与平均值的差异）之上，以解决估计问题和容错问题。<br/><br/> 10.  Problem solve and study in a small team with fellow students.<br/>  10.和同学组成小组，合作解决和研究问题。</p><p><br/></p><p/><h2>清华大学网络课程中离散数学的课程目标</h2>\n<p>本课程是计算机科学基础理论的核心课程，通过课时内的学习及课外练习，学生应能够达到以下目标：<br/>（1） 对数理逻辑与集合论的基本概念有较深入全面的了解； <br/>（2）  系统地掌握命题演算、谓词演算及朴素集合论的经典内容； <br/>（3）  学会形式化演绎推理和定理证明的基本方法； <br/>（4） 强化抽象思维能力、逻辑推理能力和缜密概括能力的培养，进而提高分析问题、解决问题的能力； <br/>（5） 为计算机专业后续课程的学习和科研工作的参与打下坚实的基础。  </p>            </div>\n                ",
			"keywords":["machine_learning"]
		}
	]
}
